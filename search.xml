<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2020/09/07/zu-jian-dong-tai-zhu-ce-ji-xuan-ran/"/>
      <url>/2020/09/07/zu-jian-dong-tai-zhu-ce-ji-xuan-ran/</url>
      
        <content type="html"><![CDATA[<h3 id="组件动态注册及渲染"><a href="#组件动态注册及渲染" class="headerlink" title="组件动态注册及渲染"></a>组件动态注册及渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;component :is&#x3D;&quot;component&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">component: require(&#39;组件路径&#39;).default</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/shu-ju-jie-gou-gai-nian/"/>
      <url>/2020/09/07/shu-ju-jie-gou-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。</p><p>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dffac82f80142bf975f8b9515b087aa~tplv-k3u1fbpfcp-zoom-1.image"></p><p>每一种数据结构都有着独特的数据存储方式，不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。正确的数据结构选择可以提高算法的效率。</p><p>下面为大家介绍它们的结构和优缺点。</p><h2 id="数组-🌈"><a href="#数组-🌈" class="headerlink" title="数组 🌈"></a>数组 🌈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>数组是由相同类型的元素的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引可以计算出该元素对应的存储地址。</p></blockquote><ul><li><strong>优点</strong></li></ul><ol><li>按照索引查询元素速度快</li><li>按照索引遍历数组方便</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>数组的大小固定后就无法扩容了</li><li>数组只能存储一种类型的数据</li></ol><ul><li><strong>扩展</strong></li></ul><ol><li>JavaScript数组中的默认存储值是undefined，其它编程语言数组的默认存储值是0或者是垃圾数据</li><li>与其它的编程语言不同，JavaScript可以访问数组中不存在的索引，会返回undefined，而其它的编程语言会报错或返回垃圾数据</li><li>JavaScript可以存储不同类型的数据，而其它的编程语言只能存储一种数据类型的数据</li><li>当JavaScript中数组的存储空间不够用时，它会自动扩容，而其它的语言数组的大小是固定的，一旦定义了，就无法改变</li><li>JavaScript中分配给数组的存储空间是不连续的，而其他编程语言中分配给数组的存储空间是连续的</li></ol><ul><li><strong>适用场景</strong> 频繁查询，对存储空间要求不大，很少增加和删除的情况。</li></ul><h2 id="栈-🎯"><a href="#栈-🎯" class="headerlink" title="栈 🎯"></a>栈 🎯</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>栈又称堆叠,是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出（LIFO, Last In First Out），从栈顶放入元素的操作叫入栈，取出元素叫出栈；</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f217c12e4f5494aa2a4089287ceadc1~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><strong>适用场景</strong> 栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列、反转列表顺序、撤销一个或一系列操作</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>这里利用栈实现一个撤销的功能</p></blockquote><p><strong>实例:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =  <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  data = []</span><br><span class="line">  maxSize</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(initialData, maxSize = -1) &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = <span class="built_in">Array</span>.isArray(initialData) ? initialData : (<span class="keyword">typeof</span> initialData == <span class="string">&quot;undefined&quot;</span> ? [] : [initialData])</span><br><span class="line">      <span class="built_in">this</span>.maxSize = maxSize</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  isFull() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.maxSize != <span class="number">-1</span> ? (<span class="built_in">this</span>.data.length == <span class="built_in">this</span>.maxSize) : <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.data.length == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  add(item) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.isFull()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.data.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  *generator() &#123;</span><br><span class="line">      <span class="keyword">while</span>(!<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">yield</span> <span class="built_in">this</span>.data.pop()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pop() &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; value, done &#125; = <span class="built_in">this</span>.generator().next() </span><br><span class="line">     <span class="keyword">if</span>(done) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stack = <span class="built_in">require</span>(<span class="string">&quot;./stack.js&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(val) &#123;</span><br><span class="line">       <span class="built_in">this</span>.value = val</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">   apply(value) &#123;</span><br><span class="line">       <span class="keyword">return</span> value + <span class="built_in">this</span>.value</span><br><span class="line">   ｝</span><br><span class="line">   undo(value) &#123;</span><br><span class="line">       <span class="keyword">return</span> value - <span class="built_in">this</span>.value </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Times</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">   apply(value) &#123;</span><br><span class="line">       <span class="keyword">return</span> value * <span class="built_in">this</span>.value</span><br><span class="line">   &#125;</span><br><span class="line">   undo(value) &#123;</span><br><span class="line">       <span class="keyword">return</span> value / <span class="built_in">this</span>.value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpsStack</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>() &#123;</span><br><span class="line">       <span class="built_in">this</span>.value = <span class="number">0</span></span><br><span class="line">       <span class="built_in">this</span>.operations = <span class="keyword">new</span> Stack()</span><br><span class="line">   &#125;</span><br><span class="line">   add(op) &#123;</span><br><span class="line">       <span class="built_in">this</span>.value = op.apply(<span class="built_in">this</span>.value)</span><br><span class="line">       <span class="built_in">this</span>.operations.add(op) </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   undo() &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">this</span>.operations.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.value = (<span class="built_in">this</span>.operations.pop()).undo(<span class="built_in">this</span>.value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> OpsStack()</span><br><span class="line">s.add(<span class="keyword">new</span> Add(<span class="number">1</span>))</span><br><span class="line">s.add(<span class="keyword">new</span> Add(<span class="number">1</span>))</span><br><span class="line">s.add(<span class="keyword">new</span> Times(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Current value: &quot;</span>, s.value)</span><br><span class="line">s.undo()</span><br><span class="line">s.undo()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Final value: &quot;</span>, s.value</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作类（Add，Times）具有两种方法：apply使该操作生效（加乘），undo表示相反的操作（减除）。</p><h2 id="队列-✍"><a href="#队列-✍" class="headerlink" title="队列 ✍"></a>队列 ✍</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08eaf94ad134443f881ec714395dace1~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><strong>适用场景</strong>因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><strong>实例:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  data = [];</span><br><span class="line">  maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(initialData, maxSize = -1) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = <span class="built_in">Array</span>.isArray(initialData) ? initialData : <span class="keyword">typeof</span> initialData == <span class="string">&#x27;undefined&#x27;</span> ? [] : [initialData];</span><br><span class="line">    <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isFull() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.maxSize != <span class="number">-1</span> ? <span class="built_in">this</span>.data.length == <span class="built_in">this</span>.maxSize : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enqueue(item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isFull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *generator() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.data.shift();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, done &#125; = <span class="built_in">this</span>.generator().next();</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要由enqueue和dequeue方法实现。通过enqueue可以将元素添加到队列中，而使用后者则可以将其删除。 这里将数组用于基本数据结构，因为它极大地简化了这两种方法。入队与将元素推送到数组中相同，通过简单的调用shift即可解决出队问题，该操作将删除第一个元素并返回它。</p><p><strong>使用:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  Queue  = <span class="built_in">require</span>(<span class="string">&#x27;./queues&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> q = <span class="keyword">new</span> Queue(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">q.enqueue(<span class="number">1</span>)</span><br><span class="line">q.enqueue(<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(x = q.dequeue()) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了我在这里展示的简单队列之外还有：</p><ul><li>优先级队列：其元素在内部按优先级值排序。</li><li>循环队列：其最后一个元素指向第一个。</li><li>双端队列：一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出（这听起来像作弊！）。</li></ul><h2 id="堆-🚀"><a href="#堆-🚀" class="headerlink" title="堆 🚀"></a>堆 🚀</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><blockquote><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象堆(heap)又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。因为队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆虽然在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。</p></blockquote><p>堆的一个经典的实现是完全二叉树(complete binary tree)，这样实现的堆称为二叉堆(binary heap)。</p><p>这里来说明一下满二叉树的概念与完全二叉树的概念。</p><p>满二叉树：除了叶子节点，所有的节点的左右孩子都不为空，就是一棵满二叉树，如下图。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32e21ca239be43f383afda0d21b1253d~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看出：满二叉树所有的节点都拥有左孩子，又拥有右孩子。 完全二叉树：不一定是一个满二叉树，但它不满的那部分一定在右下侧，如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/725bfbfe42b842c2aa57d6c363b30873~tplv-k3u1fbpfcp-zoom-1.image"></p><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99ee8e826367482fbe18912753b68e28~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><strong>特点</strong></li></ul><ol><li>任一结点的值是其子树所有结点的最大值或最小值</li><li>必须是完全二叉树</li></ol><ul><li><strong>适用场景</strong> 因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><strong>最小堆的插入（ADD）</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8434941b47d74bed838637d7f362ad16~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>假设现有元素 5 需要插入，为了维持完全二叉树的特性，新插入的元素一定是放在结点 6 的右子树；同时为了满足任一结点的值要小于左右子树的值这一特性，新插入的元素要和其父结点作比较，如果比父结点小，就要把父结点拉下来顶替当前结点的位置，自己则依次不断向上寻找，找到比自己大的父结点就拉下来，直到没有符合条件的值为止。</p></blockquote><ol><li><p>在这里先将元素 5 插入到末尾，即放在结点 6 的右子树。</p></li><li><p>然后与父类比较， 6 &gt; 5 ，父类数字大于子类数字，子类与父类交换。</p></li><li><p>重复此操作，直到不发生替换。</p><p><strong>最小堆的删除（DELETE）</strong></p><p><code>核心点：将最后一个元素填充到堆顶，然后不断的下沉这个元素。</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91edc3212e0d4f7bb4bdc5b0131c0cff~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>假设要从节点 1 ，也可以称为取出节点 1 ，为了维持完全二叉树的特性 ，我们将最后一个元素 6 去替代这个 1 ；然后比较 1 和其子树的大小关系，如果比左右子树大（如果存在的话），就要从左右子树中找一个较小的值替换它，而它能自己就要跑到对应子树的位置，再次循环这种操作，直到没有子树比它小。</p></blockquote></li></ol><p>通过这样的操作，堆依然是堆，总结一下：</p><ul><li>找到要删除的节点（取出的节点）在数组中的位置</li><li>用数组中最后一个元素替代这个位置的元素</li><li>当前位置和其左右子树比较，保证符合最小堆的节点间规则</li><li>删除最后一个元素</li></ul><h2 id="链表-🏉"><a href="#链表-🏉" class="headerlink" title="链表 🏉"></a>链表 🏉</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><blockquote><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。</p></blockquote><ul><li><strong>优点</strong></li></ul><ol><li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li><li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>因为含有大量的指针域，占用空间较大；</li><li>查找元素需要遍历链表来查找，非常耗时。</li></ol><ul><li><strong>适用场景</strong> 数据量较小，需要频繁增加，删除操作的场景</li></ul><p>根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e130ef7dad9c472dafeefc71cded8590~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><strong>循环链表的特点</strong></li></ul><p>和单链表相比，循环链表的优点是从链尾到链头比较方便，当要处理的数据具有环型结构特点时，适合采用循环链表。</p><ul><li><strong>双向链表的特点</strong></li></ul><ol><li>与单链表对比，双链表需要多一个指针用于指向前驱节点，因此如果存储同样多的数据，双向链表要比单链表占用更多的内存空间</li><li>双链表的插入和删除需要同时维护 next 和 prev 两个指针。</li><li>双链表中的元素访问需要通过顺序访问，支持双向遍历，这就是双向链表操作的灵活性根本</li></ol><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><strong>双向链表的基本操作</strong></p><ol><li><strong>添加元素</strong></li></ol><p>与单向链表相对比双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。</p><p>双向链表的添加元素包括头插法和尾插法。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f92bb5745464f0dbe8947108d783096~tplv-k3u1fbpfcp-zoom-1.image"></p><p><code>头插法：</code>将链表的左边称为链表头部，右边称为链表尾部。头插法是将右边固定，每次新增的元素都在左边头部增加。</p><p><code>尾插法：</code>将链表的左边称为链表头部，右边称为链表尾部。尾插法是将左边固定，每次新增都在链表的右边最尾部。</p><ol start="2"><li><p><strong>查询元素</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ca0a86f732411b98e6a15461409736~tplv-k3u1fbpfcp-zoom-1.image"></p><p>双向链表的灵活处就是<code>知道链表中的一个元素结构就可以向左或者向右开始遍历查找需要的元素结构。</code>因此对于一个有序链表，双向链表的按值查询的效率比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p></li><li><p><strong>删除元素</strong></p></li></ol><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li><p>删除结点中“值等于某个给定值”的结点</p></li><li><p>删除给定指针指向的结点<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2def10b981594a169aa3f2dfbbd9dbe3~tplv-k3u1fbpfcp-zoom-1.image"></p><p>对于双向链表来说，双向链表中的结点已经保存了前驱结点的指针，删除时不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度。</p></li></ul><ol start="4"><li><p>双向循环链表<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91f9c5304525467294af29c8bb37ed08~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如图所示，双向循环链表的概念很好理解：「双向链表」 + 「循环链表」的组合。</p></li></ol><h2 id="树-🏈"><a href="#树-🏈" class="headerlink" title="树 🏈"></a>树 🏈</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><blockquote><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fedd522b6e4bd796e789f95cb5fcdf~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><strong>特点</strong></li></ul><ol><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/815faea4d26d41ee9821fdf19d691d49~tplv-k3u1fbpfcp-zoom-1.image"></p><p>树的不同部分被称为：</p><ul><li>根节点/父节点(Root Node/parent Node)：在其下有子节点的节点。</li><li>叶节点(leaf nodes)：没有与其关联的子节点的节点。</li><li>边(edges)：两个节点之间的链接。</li></ul><p>树的一些定义：</p><ul><li>路径：从根节点到目标节点所需的节点列表。</li><li>树的高度：在根节点和最远的叶节点之间形成最大路径的节点数。</li></ul><p>根据数据结构可以分为不同类型的树：</p><ul><li>二叉树：二叉树是树的特殊一种，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用，它们还用于创建二进制搜索树。他的的一种潜在用例是压缩算法。具有如下特点：</li></ul><ol><li>每个结点最多有两颗子树，结点的度最大为2。</li><li>左子树和右子树是有顺序的，次序不能颠倒。</li><li>即使某结点只有一个子树，也要区分左右子树。</li></ol><ul><li>二分搜索树：也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树</li></ul><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ol><ul><li>深度优先搜索（DFS）：这是查找树的一种方式。它的工作方式是，首先先遍历整个左侧，然后回溯到最后访问的父级，然后移至右侧的子树。<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6bd778b65dc46f18126f98968fc58f4~tplv-k3u1fbpfcp-zoom-1.image"></li></ul><p>遍历结果：A-&gt; B-&gt; C-&gt; D-&gt; E。节点的顺序由DFS方法确定，也可以按相反的顺序遍历。</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p><strong>实例:</strong></p><blockquote><p>实现一个二叉搜索树</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">   <span class="built_in">this</span>.value = value;</span><br><span class="line">   <span class="built_in">this</span>.left_child = <span class="literal">null</span>;</span><br><span class="line">   <span class="built_in">this</span>.right_child = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> compare(v) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.value &gt; v) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.value == v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; v) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">   <span class="built_in">this</span>.root_node = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> add(elem) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.root_node) &#123;</span><br><span class="line">     <span class="built_in">this</span>.root_node = <span class="keyword">new</span> BinaryTreeNode(elem);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> inserted = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.root_node;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> comp = currentNode.compare(elem);</span><br><span class="line">     <span class="keyword">if</span> (comp == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!currentNode.left_child) &#123;</span><br><span class="line">         currentNode.left_child = <span class="keyword">new</span> BinaryTreeNode(elem);</span><br><span class="line">         inserted = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         currentNode = currentNode.left_child;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (comp != <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!currentNode.right_child) &#123;</span><br><span class="line">         currentNode.right_child = <span class="keyword">new</span> BinaryTreeNode(elem);</span><br><span class="line">         inserted = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         currentNode = currentNode.right_child;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> (!inserted);</span><br><span class="line"> &#125;</span><br><span class="line"> inorder(parent) &#123;</span><br><span class="line">   <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">     <span class="built_in">this</span>.inorder(parent.left_child);</span><br><span class="line">     <span class="built_in">console</span>.log(parent.value);</span><br><span class="line">     <span class="built_in">this</span>.inorder(parent.right_child);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> print() &#123;</span><br><span class="line">   <span class="built_in">this</span>.inorder(<span class="built_in">this</span>.root_node);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tree = <span class="built_in">require</span>(<span class="string">&quot;./bst&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Tree()</span><br><span class="line">t.add(<span class="number">10</span>)</span><br><span class="line">t.add(<span class="number">8</span>)</span><br><span class="line">t.add(<span class="number">11</span>)</span><br><span class="line">t.add(<span class="number">23</span>)</span><br><span class="line">t.add(<span class="number">1</span>)</span><br><span class="line">t.add(<span class="number">9</span>)</span><br><span class="line">t.print()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最复杂的方法是add。它主要由do while遍历树的循环组成，以寻找新值的位置。 inorder方法只是遍历顺序的快速递归实现（先左移，然后居中，然后右移）。你可以切换顺序以相反的顺序遍历它。</p><blockquote><p><strong>扩展：</strong> 二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p></blockquote><h2 id="图-🏂"><a href="#图-🏂" class="headerlink" title="图 🏂"></a>图 🏂</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><blockquote><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ef909a6a9643afb87de1c8de755a30~tplv-k3u1fbpfcp-zoom-1.image"></p><p>按照顶点指向的方向可分为无向图和有向图： 图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构</p><ul><li><strong>适用场景</strong></li></ul><p>图是非常通用的，因为它们可用于表示实体相互连接的几乎所有场景。我说的是用例，范围从网络布局到基于微服务的体系结构，再到真实世界的地图，再到你可以想象的任何事物。</p><p>如此之多，以至于整个数据库引擎都基于图的概念（例如Neo4J是一种非常流行的引擎）。我们刚刚涵盖的树中的所有概念（例如边，节点，路径等）在这里仍然有效。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>这里展示一个简单的树，包括一种如何实现深度优先搜索遍历的方法（请查看“树”部分以了解其含义）。</p><p><strong>实例:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">       <span class="built_in">this</span>.value = value</span><br><span class="line">       <span class="built_in">this</span>.links = []</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   linkTo(node, weight) &#123;</span><br><span class="line">       <span class="built_in">this</span>.links.push(<span class="keyword">new</span> Link(<span class="built_in">this</span>, weight, node))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">constructor</span>(a, weight, b) &#123;</span><br><span class="line">       <span class="built_in">this</span>.left = a;</span><br><span class="line">       <span class="built_in">this</span>.weight = weight</span><br><span class="line">       <span class="built_in">this</span>.right = b</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">constructor</span>(root_node) &#123;</span><br><span class="line">       <span class="built_in">this</span>.root_node = root_node</span><br><span class="line">       <span class="built_in">this</span>.dfs_visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   dfs(starting_node) &#123;</span><br><span class="line">       <span class="keyword">if</span>(!starting_node) starting_node = <span class="built_in">this</span>.root_node</span><br><span class="line">       <span class="keyword">let</span> node = starting_node </span><br><span class="line">       <span class="built_in">console</span>.log(node.value);</span><br><span class="line">       <span class="built_in">this</span>.dfs_visited.add(node);</span><br><span class="line">       node.links.forEach( <span class="function"><span class="params">neighbour</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="built_in">this</span>.dfs_visited.has(neighbour.right)) &#123;</span><br><span class="line">               <span class="built_in">this</span>.dfs(neighbour.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用:</strong></p><p>每个节点都有一个“links”列表，它们表示两个节点之间的关系。并且你可以在任何地方添加想要的值（例如，网络连接的ms延迟，两个位置之间的流量或几乎所有内容只要你想）。 使用dfs方法遍历图，确保每个节点只访问一次。这里展示一个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> Node(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> B = <span class="keyword">new</span> Node(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> C = <span class="keyword">new</span> Node(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> D = <span class="keyword">new</span> Node(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> E = <span class="keyword">new</span> Node(<span class="string">&quot;E&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> F = <span class="keyword">new</span> Node(<span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> G = <span class="keyword">new</span> Node(<span class="string">&quot;G&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A.linkTo(B, <span class="number">1</span>)</span><br><span class="line">A.linkTo(C, <span class="number">2</span>)</span><br><span class="line">B.linkTo(D, <span class="number">1</span>)</span><br><span class="line">C.linkTo(E, <span class="number">10</span>)</span><br><span class="line">D.linkTo(E, <span class="number">10</span>)</span><br><span class="line">D.linkTo(F, <span class="number">1</span>)</span><br><span class="line">D.linkTo(G, <span class="number">1</span>)</span><br><span class="line">G.linkTo(G, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> Graph(A)</span><br><span class="line"></span><br><span class="line">g.dfs()</span><br></pre></td></tr></table></figure><p>换句话说，每个节点只能访问一次。您可以使用图做更多有趣的事情，例如实现Dijkstra的算法以找到两个节点之间的最短路径，或者采用AI路线并实现神经网络。想象力是Graphs的极限，所以暂时不要纠正它们，给它们一个机会。</p><h2 id="散列表-🎉"><a href="#散列表-🎉" class="headerlink" title="散列表 🎉"></a>散列表 🎉</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><blockquote><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69a554efc185469b9dc81a5f0aacf8c8~tplv-k3u1fbpfcp-zoom-1.image"></p><p>记录的存储位置=f(key)</p><p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。它允许存储键值对并快速检索它们（有人会说它的复杂度为O（1）最佳情况），是非常惊人的。哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等。</p><ul><li><strong>优点</strong></li></ul><ol><li>利用hash表的优势，对于集合的查找元素时非常方便；</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的；</li></ol><ul><li><strong>适用场景</strong> 哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。如果实施得当，该结构将非常有效，以至于广泛用于诸如数据库索引（通常在需要快速查找操作时将字段设置为索引）等场景，甚至是缓存实现，从而允许快速查找操作以进行检索缓存的内容。正如您可能已经猜到的，如果您希望进行快速且重复的查找，那么这是一个很好的结构。</li></ul><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><p>在JavaScript中，实现哈希映射非常容易，因为我们有对象字面量可以用来添加随机属性（即键）。这是实现一个允许使用数字键的哈希映射。</p><p><strong>实例:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">constructor</span>() &#123;</span><br><span class="line">       <span class="built_in">this</span>.map = &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   hash(k) &#123;</span><br><span class="line">       <span class="keyword">return</span> k % <span class="number">10</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   add(key, value) &#123;</span><br><span class="line">       <span class="keyword">let</span> k = <span class="built_in">this</span>.hash(key)</span><br><span class="line">       <span class="keyword">if</span>(!<span class="built_in">this</span>.map[k]) &#123;</span><br><span class="line">           <span class="built_in">this</span>.map[k] = []</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.map[k].push(value)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   get(key) &#123;</span><br><span class="line">       <span class="keyword">let</span> k = <span class="built_in">this</span>.hash(key)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.map[k]</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> HashMap()</span><br><span class="line"></span><br><span class="line">h.add(<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">h.add(<span class="number">100001</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">h.add(<span class="number">1</span>, <span class="string">&quot;this is a string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(h)</span><br></pre></td></tr></table></figure><p><strong>使用:</strong></p><p><code>输出结果如下</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap &#123;</span><br><span class="line">map: &#123; <span class="string">&#x27;0&#x27;</span>: [ <span class="string">&#x27;hello&#x27;</span> ], <span class="string">&#x27;1&#x27;</span>: [ <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;this is a string&#x27;</span> ] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>为了确保我们最多只保留10个key，我的hash方法做了一个余10的操作导致”world”与”this is a string”跟同一个key关联，这就是所谓的哈希冲突。如果你的内存有限，或者出于某种原因需要严格控制键，这将很有帮助。实现哈希方法的方式将决定哈希映射的最终效果。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/shu-ru-url-hou-dao-ye-mian-xuan-ran-de-guo-cheng/"/>
      <url>/2020/09/07/shu-ru-url-hou-dao-ye-mian-xuan-ran-de-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h3><p>从浏览器输入 <code>URL</code> 到页面渲染的整个过程都是由 浏览器架构中的各个进程之间的配合完成。</p><ol><li>浏览器主进程: 管理子进程、提供服务功能</li><li>渲染进程：将HTML、CSS、JS渲染成界面，js引擎v8和排版引擎Blink就在上面，他会为每一个tab页面创建一个渲染进程</li><li>GPU进程：本来是负责处理3Dcss的，后来慢慢的UI界面也交给GPU来绘制</li><li>网络进程：就是负责网络请求，网络资源加载的进程</li><li>插件进程：负责插件的运行的，因为插件很容易崩溃，把它放到独立的进程里不要让它影响别人</li></ol><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>从用户输入信息到页面展示的不同阶段，是不同的进程在发挥作用，示意图如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c511a2f4f5f450c9ec5972451b80f35~tplv-k3u1fbpfcp-zoom-1.image"></p><p>从图中可以看出，整个过程是需要各个进程之间相互配合完成的，过程大致可以描述为：</p><ol><li><p>用户输入url,处理输入信息，主进程开始导航，交给网络进程干活</p></li><li><p>网络进程发起网络请求，其中有可能会发生重定向</p></li><li><p>服务器响应URL之后，主进程就要通知渲染进程，你要开始干活了</p></li><li><p>渲染进程准备好了，要想渲染进程提交数据，这个时间叫做提交文档</p></li><li><p>渲染进程接受到数据，完成页面渲染。</p></li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="1-输入url"><a href="#1-输入url" class="headerlink" title="1.输入url"></a>1.输入url</h4><p>用户输入url，处理输入信息：</p><p>如果为非url结构的字符串，交给浏览器<strong>默认引擎</strong>去搜索改字符串；</p><p>若为url结构的字符串，浏览器主进程会交给 <strong>网络进程</strong> ,开始干活。</p><h4 id="2-1查找浏览器缓存"><a href="#2-1查找浏览器缓存" class="headerlink" title="2.1查找浏览器缓存"></a>2.1查找浏览器缓存</h4><p>网络进程会先看看是否存在本地缓存，如果有就直接返回资源给浏览器进程，无则下一步 DNS-&gt; IP -&gt; TCP</p><h4 id="2-2DNS解析"><a href="#2-2DNS解析" class="headerlink" title="2.2DNS解析"></a>2.2DNS解析</h4><p>网络进程拿到url后，先会进行DNS域名解析得到<strong>IP地址</strong>。如果请求协议是HTTPS，那么还需要建立TLS连接。</p><h4 id="2-3建立TCP连接，三次握手"><a href="#2-3建立TCP连接，三次握手" class="headerlink" title="2.3建立TCP连接，三次握手"></a>2.3建立TCP连接，三次握手</h4><p>接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，向服务器发送请求。</p><h4 id="3服务器响应"><a href="#3服务器响应" class="headerlink" title="3服务器响应"></a>3服务器响应</h4><p>服务器收到请求信息后，会根据请求信息生成响应行、响应头、响应体，并发给网络进程。网络进程接受了响应信息之后，就开始解析响应头的内容。</p><p><strong>网络进程解析响应行和响应头信息的过程：</strong></p><h5 id="3-1重定向"><a href="#3-1重定向" class="headerlink" title="3.1重定向"></a>3.1重定向</h5><p>如果响应行状态码为301（永久重定向）和302（临时），那么说明需要重定向到其他url。这时候网络进程会从响应头中的Location字段里读取重定向的地址，并重新发起网络请求。</p><h5 id="3-2-响应数据处理"><a href="#3-2-响应数据处理" class="headerlink" title="3.2 响应数据处理"></a>3.2 响应数据处理</h5><p>导航会通过请求头的<strong>Content-type</strong>字段判断响应体数据的类型。浏览器通过这个来决定如何显示响应体的内容。</p><p>比如：若为application/octet-stream，则会按照下载类型来处理这个请求，导航结束。</p><p>若为text/html，这就告诉浏览器服务器返回的是html格式，浏览器会通知渲染进程，你要干活了。</p><h4 id="4-准备渲染进程"><a href="#4-准备渲染进程" class="headerlink" title="4 准备渲染进程"></a>4 准备渲染进程</h4><p>默认情况，每个页面一个渲染进程。但若处于<strong>同一站点</strong>（同根域名+协议），那么渲染进程就会复用。</p><h4 id="5提交文档"><a href="#5提交文档" class="headerlink" title="5提交文档"></a>5提交文档</h4><p>渲染进程准备好后，浏览器进程发出<strong>“提交文档的消息”</strong>，渲染进程接受了消息之后，会跟网络进程建立传输数据的管道。</p><p>等数据传输完成了，渲染进程会告诉浏览器进程，<strong>确认文档提交</strong>，这时候浏览器会更新页面，安全状态，url，前进后退的历史。</p><p>到这里导航结束，进入渲染阶段。</p><p>注：当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为百度首页的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><blockquote><p><a href="https://www.jianshu.com/p/6335e46e2ace">参考地址</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/15050783-c14e5c2c54996b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/646/format/webp"></p><ol><li><p>浏览器无法直接读取html，需要先构建<strong>Dom</strong>树。</p></li><li><p>把读取到的css，变成浏览器可以理解的<strong>cssom</strong>树。</p><p><strong>转换样式表中的属性值，使其标准化</strong>。2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……</p><p><strong>计算出 DOM 树中每个节点的具体样式</strong>。利用css继承、css优先级、css层叠规则等计算出来。</p></li><li><p>浏览器会先从DOM树的根节点开始遍历每个可见节点，并把这些节点添加到<strong>渲染</strong>树中。不可见的节点不会添加到渲染树，比如css设置了display为none 属性的节点。</p></li><li><p>根据生成的渲染树，进行<strong>布局</strong>（也可以叫做回流），得到各个节点在页面中的确切位置和大小。（自动重排）。布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换为屏幕内的绝对像素值（重绘）。</p></li><li><p>生成分层树，页面都是一层一层叠加在一起形成的。比如一些复杂的css动画，z-index等，渲染引擎会为他们生成专用的图层，并生成对应的<strong>图层树</strong>。</p></li><li><p>构建完图层之后，渲染引擎会对图层树中的每个元素进行<strong>绘制</strong>。合成线程会把分层树的图层变成<strong>图块</strong>。</p></li><li><p>GPU的栅格化把视窗附近的图块变成位图，然后保存在GPU的进程中。（因为一个页面可能很大，而用户只能看到视口中页面的一部分，如果全部绘制开销会很大，所以合成线程会按照视口附近的图块来优先生成位图）</p></li><li><p>栅格化完成之后，浏览器进去GPU进程里取出页面内容显示在屏幕上，这就完成了渲染阶段</p></li></ol><h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><blockquote><p>回流发生在浏览器渲染页面的过程里，由DOM树和样式计算出布局树的过程就叫做回流，这个步骤需要计算出每个元素的大小和位置（忽略display:none的元素）</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1eba4d26f674f13b6fdffc2dd8173d2~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><blockquote><p>我们将布局树和样式转换为屏幕上的实际像素，这个阶段就叫做重绘节点。所以，<strong>回流必定导致重绘，重绘却不一定回流，且回流的代价比重绘高。</strong></p><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。</p></blockquote><h4 id="何时发生回流和重绘"><a href="#何时发生回流和重绘" class="headerlink" title="何时发生回流和重绘"></a>何时发生回流和重绘</h4><ol><li>浏览器窗口尺寸变化（因为回流是根据视口的大小来计算元素的大小和位置的）</li><li>页面一开始渲染的时候</li><li>添加或者删除dom</li><li>修改元素位置或者尺寸</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="浏览器的性能优化机制"><a href="#浏览器的性能优化机制" class="headerlink" title="浏览器的性能优化机制"></a>浏览器的性能优化机制</h4><ul><li>浏览器自身有优化，它会维持一个待更新队列，类似批处理的方式来优化，只有当队列中的任务或者时间间隔达到一个阈值，浏览器就会将队列清空，这样可以把多次回流和重绘变成一次。但是如果触发了同步布局事件，浏览器就会强制flush这个队列（立即清空队列）。所以我们要避免触发同步布局事件，我们熟悉的有如下：</li></ul><blockquote><p>getBoundingClientRect、getComputedStyle()、offsetTop、scrollWidth、<code>clientWidth</code>、</p></blockquote><h4 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="headerlink" title="如何减少回流和重绘"></a>如何减少回流和重绘</h4><ul><li>最小化重排重绘<ol><li>使用el.style.cssText</li><li>直接添加类名</li></ol></li><li>避免频繁操作DOM结构,如果需要可以先把他们<code>display：none</code>(因为这些元素不会出现不会触发回流重绘)，等待dom操作结束后在把他们放出来</li><li>具有复杂动画操作的元素使用绝对定位，使其<strong>脱离文档流</strong>减少父节点和后续节点的频繁回流</li><li>css3硬件加速 / GPU加速，就是使用一些css开启CUP加速 ，如transform、opacity、filters，这些动画不会引起回流重绘</li></ul><p><a href="https://juejin.im/user/3491704662666654"></a></p><p><a href="https://juejin.im/extension/?utm_source=juejin.im&utm_medium=post&utm_campaign=extension_promotion">安装掘金浏览器插件</a></p><p>打开新标签页发现好内容，掘金、GitHub、Dribbble、ProductHunt 等站点内容轻松获取。快来安装掘金浏览器插件获取高质量内容吧！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/qian-duan-mian-shi-ti/"/>
      <url>/2020/09/07/qian-duan-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>HTML语义化就是让页面内容结构化，它有如下优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。</span><br><span class="line">2、有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</span><br><span class="line">3、方便其他设备解析，如盲人阅读器根据语义渲染网页</span><br><span class="line">4、有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;代表头部</span><br><span class="line">&lt;nav&gt;代表超链接区域</span><br><span class="line">&lt;main&gt;定义文档主要内容</span><br><span class="line">&lt;article&gt;可以表示文章、博客等内容</span><br><span class="line">&lt;aside&gt;通常表示侧边栏或嵌入内容</span><br><span class="line">&lt;footer&gt;代表尾部</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="HTML5新标签"><a href="#HTML5新标签" class="headerlink" title="HTML5新标签"></a>HTML5新标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有&lt;header&gt;、&lt;footer&gt;、&lt;aside&gt;、&lt;nav&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;canvas&gt;等...</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>盒模型分为标准盒模型和怪异盒模型(IE模型)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box-sizing：content-box   &#x2F;&#x2F;标准盒模型</span><br><span class="line">box-sizing：border-box    &#x2F;&#x2F;怪异盒模型</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/9/9/16d1528aff0ef536?imageslim"></p><p>标准盒模型：元素的宽度等于style里的width+margin+border+padding宽度</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/9/16d158cb1351e5b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><p>如下代码，整个宽高还是120px</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    box-sizing: content-box;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>怪异盒模型：元素宽度等于style里的width宽度</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/9/16d158e2ebd5fefe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><p>如下代码，整个宽高还是100px</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>注意：如果你在设计页面中，发现内容区被撑爆了，那么就先检查一下border-sizing是什么，最好在引用reset.css的时候，就对border-sizing进行统一设置，方便管理</p><h3 id="rem与em的区别"><a href="#rem与em的区别" class="headerlink" title="rem与em的区别"></a>rem与em的区别</h3><blockquote><p>rem是根据根的font-size变化，而em是根据父级的font-size变化</p></blockquote><p>rem：相对于根元素html的font-size，假如html为font-size：12px，那么，在其当中的div设置为font-size：2rem,就是当中的div为24px</p><p>em：相对于父元素计算，假如某个p元素为font-size:12px,在它内部有个span标签，设置font-size：2em,那么，这时候的span字体大小为：12*2=24px</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p><strong>css常用选择器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通配符：*</span><br><span class="line">ID选择器：</span><br><span class="line">类选择器：.class</span><br><span class="line">元素选择器：p、a    等</span><br><span class="line">后代选择器：p span、div a   等</span><br><span class="line">伪类选择器：a:hover 等</span><br><span class="line">属性选择器：input[type&#x3D;&quot;text&quot;]  等</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>css选择器权重</strong></p><p>!important -&gt; 行内样式 -&gt; #id -&gt; .class -&gt; 元素和伪元素 -&gt; * -&gt; 继承 -&gt; 默认</p><h3 id="CSS新特性"><a href="#CSS新特性" class="headerlink" title="CSS新特性"></a>CSS新特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transition：过渡</span><br><span class="line">transform：旋转、缩放、移动或者倾斜</span><br><span class="line">animation：动画</span><br><span class="line">gradient：渐变</span><br><span class="line">shadow：阴影</span><br><span class="line">border-radius：圆角</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h3><p><strong>行内元素（display: inline）</strong></p><p>宽度和高度是由内容决定，与其他元素共占一行的元素，我们将其叫行内元素，例如：<code>&lt;span&gt; 、 &lt;i&gt; 、 &lt;a&gt;</code>等</p><p><strong>块级元素（display: block)</strong></p><p>默认宽度由父容器决定，默认高度由内容决定，独占一行并且可以设置宽高的元素，我们将其叫做块级元素，例如：<code>&lt;p&gt; 、&lt;div&gt; 、&lt;ul&gt;等</code></p><p>在平时，我们经常使用CSS的display: inline-block，使它们拥有更多的状态</p><h3 id="绝对定位和相对定位的区别"><a href="#绝对定位和相对定位的区别" class="headerlink" title="绝对定位和相对定位的区别"></a>绝对定位和相对定位的区别</h3><p><strong>position: absolute</strong><br>绝对定位：是相对于元素最近的已定位的祖先元素</p><p><strong>position: relative</strong><br>相对定位：相对定位是相对于元素在文档中的初始位置</p><h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p><a href="https://juejin.im/post/6844903906925887502">juejin.im/post/684490…</a></p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><strong>什么是BFC?</strong></p><p>BFC格式化上下文，它是一个独立的渲染区域，让处于 BFC 内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响</p><p><strong>如何产生BFC?</strong></p><p>display: inline-block</p><p>position: absolute/fixed</p><p><strong>BFC作用</strong></p><p>BFC最大的一个作用就是：在页面上有一个独立隔离容器，容器内的元素和容器外的元素布局不会相互影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决上外边距重叠;重叠的两个box都开启bfc;</span><br><span class="line">解决浮动引起高度塌陷;容器盒子开启bfc</span><br><span class="line">解决文字环绕图片;左边图片div,右边文字容器p,将p容器开启bfc</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p><strong>Flex布局</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display: flex  &#x2F;&#x2F;设置Flex模式</span><br><span class="line">flex-direction: column  &#x2F;&#x2F;决定元素是横排还是竖着排</span><br><span class="line">flex-wrap: wrap     &#x2F;&#x2F;决定元素换行格式</span><br><span class="line">justify-content: space-between  &#x2F;&#x2F;同一排下对齐方式，空格如何隔开各个元素</span><br><span class="line">align-items: center     &#x2F;&#x2F;同一排下元素如何对齐</span><br><span class="line">align-content: space-between    &#x2F;&#x2F;多行对齐方式</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>水平居中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行内元素：display: inline-block;</span><br><span class="line">块级元素：margin: 0 auto;</span><br><span class="line">Flex: display: flex; justify-content: center</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>垂直居中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行高 &#x3D; 元素高：line-height: height</span><br><span class="line">flex: display: flex; align-item: center</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="less-sass-styus三者的区别"><a href="#less-sass-styus三者的区别" class="headerlink" title="less,sass,styus三者的区别"></a>less,sass,styus三者的区别</h3><p><strong>变量</strong></p><p>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。</p><p>Less 声明变量用『@』开头，其余等同 Sass。</p><p>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。</p><p><strong>作用域</strong></p><p>Sass：三者最差，不存在全局变量的概念</p><p>Less：最近的一次更新的变量有效，并且会作用于全部的引用！</p><p>Stylus：Sass 的处理方式和 Stylus 相同，变量值输出时根据之前最近的一次定义计算，每次引用最近的定义有效；</p><p><strong>嵌套</strong></p><p>三种 css 预编译器的「选择器嵌套」在使用上来说没有任何区别，甚至连引用父级选择器的标记 &amp; 也相同</p><p><strong>继承</strong></p><p>Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。Stylus 的继承方式来自 Sass，两者如出一辙。 Less 则又「独树一帜」地用伪类来描述继承关系；</p><p><strong>导入@Import</strong></p><p>Sass 中只能在使用 url() 表达式引入时进行变量插值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$device: mobile;</span><br><span class="line">@import url(styles.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>Less 中可以在字符串中进行插值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@device: mobile;</span><br><span class="line">@import &quot;styles.@&#123;device&#125;.css&quot;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>Stylus 中在这里插值不管用，但是可以利用其字符串拼接的功能实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device &#x3D; &quot;mobile&quot;</span><br><span class="line">@import &quot;styles.&quot; + device + &quot;.css&quot;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。</p><p>Sass 和 Compass、Stylus 和 Nib 都是好基友。</p><p>Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能，这方面 Less 比不上 Sass 和 Stylus</p><p>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用（个人愚见）</p><h3 id="link与-import区别与选择"><a href="#link与-import区别与选择" class="headerlink" title="link与@import区别与选择"></a>link与@import区别与选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">@import url(CSS文件路径地址);</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;link href&#x3D;&quot;CSSurl路径&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css；</p><p>当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载；</p><p>@import需要 IE5 以上才能使用；</p><p>link可以使用 js 动态引入，@import不行</p><h3 id="多行元素的文本省略号"><a href="#多行元素的文本省略号" class="headerlink" title="多行元素的文本省略号"></a>多行元素的文本省略号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">overflow : hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 3;</span><br><span class="line">-webkit-box-orient: vertical</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JS的几条基本规范"><a href="#JS的几条基本规范" class="headerlink" title="JS的几条基本规范"></a>JS的几条基本规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、不要在同一行声明多个变量</span><br><span class="line">2、请使用&#x3D;&#x3D;&#x3D;&#x2F;！&#x3D;&#x3D;来比较true&#x2F;false或者数值</span><br><span class="line">3、使用对象字面量替代new Array这种形式</span><br><span class="line">4、不要使用全局变量</span><br><span class="line">5、Switch语句必须带有default分支</span><br><span class="line">6、函数不应该有时候有返回值，有时候没有返回值</span><br><span class="line">7、For循环必须使用大括号</span><br><span class="line">8、IF语句必须使用大括号</span><br><span class="line">9、for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="JS引用方法"><a href="#JS引用方法" class="headerlink" title="JS引用方法"></a>JS引用方法</h3><p><strong>行内引入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&quot;alert(&#39;行内引入&#39;)&quot; value&#x3D;&quot;按钮&quot;&#x2F;&gt;</span><br><span class="line">  &lt;button onclick&#x3D;&quot;alert(123)&quot;&gt;点击我&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>内部引入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload &#x3D; function() &#123;</span><br><span class="line">    alert(&quot;js 内部引入！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>外部引入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1，不推荐写行内或者HTML中插入&lt;script&gt;,因为浏览器解析顺序缘故，如果解析到死循环之类的JS代码，会卡住页面</span><br><span class="line">2，建议在onload事件之后，即等HTML、CSS渲染完毕再执行代码</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="JS的基本数据类型"><a href="#JS的基本数据类型" class="headerlink" title="JS的基本数据类型"></a>JS的基本数据类型</h3><p>Undefined、Null、Boolean、Number、String、新增:Symbol</p><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><blockquote><p>在 JavaScript 中，用得较多的之一无疑是数组操作，这里过一遍数组的一些用法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map: 遍历数组，返回回调返回值组成的新数组</span><br><span class="line">forEach: 无法break，可以用try&#x2F;catch中throw new Error来停止</span><br><span class="line">filter: 过滤</span><br><span class="line">some: 有一项返回true，则整体为true</span><br><span class="line">every: 有一项返回false，则整体为false</span><br><span class="line">join: 通过指定连接符生成字符串</span><br><span class="line">push &#x2F; pop: 末尾推入和弹出，改变原数组， 返回推入&#x2F;弹出项【有误】</span><br><span class="line">unshift &#x2F; shift: 头部推入和弹出，改变原数组，返回操作项【有误】</span><br><span class="line">sort(fn) &#x2F; reverse: 排序与反转，改变原数组</span><br><span class="line">concat: 连接数组，不影响原数组， 浅拷贝</span><br><span class="line">slice(start, end): 返回截断后的新数组，不改变原数组</span><br><span class="line">splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组</span><br><span class="line">indexOf &#x2F; lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标</span><br><span class="line">reduce &#x2F; reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="JS有哪些内置对象"><a href="#JS有哪些内置对象" class="headerlink" title="JS有哪些内置对象"></a>JS有哪些内置对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object是JavaScript中所有对象的父对象</span><br><span class="line"></span><br><span class="line">数据封装对象：Object、Array、Boolean、Number和String</span><br><span class="line">其他对象：Function、Arguments、Math、Date、RegExp、Error</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="get请求传参长度的误区"><a href="#get请求传参长度的误区" class="headerlink" title="get请求传参长度的误区"></a>get请求传参长度的误区</h3><p>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的</p><p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p><p>1、HTTP 协议 未规定 GET 和POST的长度限制</p><p>2、GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</p><p>3、不同的浏览器和WEB服务器，限制的最大长度不一样</p><p>4、要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</p><h3 id="补充get和post请求在缓存方面的区别"><a href="#补充get和post请求在缓存方面的区别" class="headerlink" title="补充get和post请求在缓存方面的区别"></a>补充get和post请求在缓存方面的区别</h3><ul><li><p>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p></li><li><p>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>什么是闭包？</strong></p><p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。</p><p>又或者：闭包就是能够读取其他函数内部变量的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  var a &#x3D; 1;</span><br><span class="line">  function B() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  return B();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>闭包的特征</strong></p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收制回收</li></ul><p><strong>对闭包的理解</strong></p><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p><p>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</p><p>闭包的另一个用处，是封装对象的私有属性和私有方法</p><p><strong>闭包的好处</strong></p><p>能够实现封装和缓存等</p><p><strong>闭包的坏处</strong></p><p>就是消耗内存、不正当使用会造成内存溢出的问题</p><p><strong>使用闭包的注意点</strong></p><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</p><p>解决方法是：在退出函数之前，将不使用的局部变量全部删除</p><p><strong>闭包的经典问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这段代码输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：3个3</span><br><span class="line">解析：首先，for 循环是同步代码，先执行三遍 for，i 变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>有什么办法依次输出0 1 2</p><blockquote><p>第一种方法</p></blockquote><p>使用let</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在这里，每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2</p><p>如果这样不明白，我们可以执行下边这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  console.log(&quot;定时器外部：&quot; + i);</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>此时浏览器依次输出的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定时器外部：0</span><br><span class="line">定时器外部：1</span><br><span class="line">定时器外部：2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>即代码还是先执行 for 循环，但是当 for 结束执行到了 setTimeout 的时候，它会做个标记，这样到了 console.log(i) 中，i 就能找到这个块中最近的变量定义</p><blockquote><p>第二种方法</p></blockquote><p>使用立即执行函数解决闭包的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  (function(i)&#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="JS作用域及作用域链"><a href="#JS作用域及作用域链" class="headerlink" title="JS作用域及作用域链"></a>JS作用域及作用域链</h3><p><strong>作用域</strong></p><p>在JavaScript中，作用域分为 全局作用域 和 函数作用域</p><blockquote><p>全局作用域</p></blockquote><p>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域</p><blockquote><p>函数作用域</p></blockquote><p>在固定的代码片段才能被访问</p><p>例子：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/16/16d382c7d68e17ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p><p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p>变量取值：到创建 这个变量 的函数的作用域中取值</p><p><strong>作用域链</strong></p><p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p><p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/16/16d3830bf3cf1ebf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p><strong>原型和原型链的概念</strong></p><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去</p><p><strong>原型和原型链的关系</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance.constructor.prototype &#x3D; instance.__proto__</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>原型和原型链的特点</strong></p><p>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</p><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</p><p>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p><h3 id="组件化和模块化"><a href="#组件化和模块化" class="headerlink" title="组件化和模块化"></a>组件化和模块化</h3><p><strong>组件化</strong></p><p><strong>为什么要组件化开发</strong></p><p>有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低</p><p><strong>组件化开发的优点</strong></p><p>很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性。这对前端工程化及降低代码的维护来说，是有很大的好处的，耦合性的降低，提高了系统的伸展性，降低了开发的复杂度，提升开发效率，降低开发成本</p><p><strong>组件化开发的原则</strong></p><ul><li><p>专一</p></li><li><p>可配置性</p></li><li><p>标准性</p></li><li><p>复用性</p></li><li><p>可维护性</p></li></ul><p><strong>模块化</strong></p><p><strong>为什么要模块化</strong></p><p>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切</p><p><strong>模块化的好处</strong></p><ul><li><p>避免变量污染，命名冲突</p></li><li><p>提高代码复用率</p></li><li><p>提高了可维护性</p></li><li><p>方便依赖关系管理</p></li></ul><p><strong>模块化的几种方法</strong></p><ul><li>函数封装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myModule &#x3D; &#123;</span><br><span class="line">    var1: 1,</span><br><span class="line">    </span><br><span class="line">    var2: 2,</span><br><span class="line">    </span><br><span class="line">    fn1: function()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    fn2: function()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</span><br><span class="line"></span><br><span class="line">缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li>立即执行函数表达式(IIFE)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var myModule &#x3D; (function()&#123;</span><br><span class="line">    var var1 &#x3D; 1;</span><br><span class="line">    var var2 &#x3D; 2;</span><br><span class="line">    </span><br><span class="line">    function fn1()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    function fn2()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">    fn1: fn1,</span><br><span class="line">    fn2: fn2</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：这样在模块外部无法修改我们没有暴露出来的变量、函数</span><br><span class="line"></span><br><span class="line">缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="图片的预加载和懒加载"><a href="#图片的预加载和懒加载" class="headerlink" title="图片的预加载和懒加载"></a>图片的预加载和懒加载</h3><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数</li></ul><p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。</p><h3 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h3><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p><p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p><h3 id="解决异步回调地狱"><a href="#解决异步回调地狱" class="headerlink" title="解决异步回调地狱"></a>解决异步回调地狱</h3><p>promise、generator、async/await</p><h3 id="对This对象的理解"><a href="#对This对象的理解" class="headerlink" title="对This对象的理解"></a>对This对象的理解</h3><p>this总是指向函数的直接调用者（而非间接调用者）</p><p>如果有new关键字，this指向new出来的那个对象</p><p>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p><strong>什么是Vue生命周期？</strong></p><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期</p><p><strong>Vue生命周期的作用是什么？</strong></p><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p><p><strong>Vue生命周期总共有几个阶段？</strong></p><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p><p><strong>第一次页面加载会触发哪几个钩子？</strong></p><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p><p><strong>DOM渲染在哪个周期中就已经完成？</strong></p><p>DOM 渲染在 mounted 中就已经完成了</p><p><strong>每个生命周期适合哪些场景？</strong></p><p>生命周期钩子的一些使用方法：</p><p>beforecreate : 可以在这加个loading事件，在加载实例时触发</p><p>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</p><p>mounted : 挂载元素，获取到DOM节点</p><p>updated : 如果对数据统一处理，在这里写上相应函数</p><p>beforeDestroy : 可以做一个确认停止事件的确认框</p><p>nextTick : 更新数据后立即操作dom</p><h3 id="v-show与v-if区别"><a href="#v-show与v-if区别" class="headerlink" title="v-show与v-if区别"></a>v-show与v-if区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建</p><p>使用 频繁切换时用v-show，运行时较少改变时用v-if</p><p>v-if=‘false’ v-if是条件渲染，当false的时候不会渲染</p><h3 id="开发中常用的指令有哪些"><a href="#开发中常用的指令有哪些" class="headerlink" title="开发中常用的指令有哪些"></a>开发中常用的指令有哪些</h3><p>v-model :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定</p><p>v-html: 更新元素的 innerHTML</p><p>v-show 与 v-if: 条件渲染, 注意二者区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成</span><br><span class="line">v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>v-on : click: 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数 v-for:基于源数据多次渲染元素或模板块 v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：v-bind:title&#x3D;&quot;msg&quot; 简写：:title&#x3D;&quot;msg&quot;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="绑定class的数组用法"><a href="#绑定class的数组用法" class="headerlink" title="绑定class的数组用法"></a>绑定class的数组用法</h3><p>对象方法 v-bind:class=”{‘orange’: isRipe, ‘green’: isNotRipe}”</p><p>数组方法 v-bind:class=”[class1, class2]“</p><p>行内 v-bind:style=”{color: color, fontSize: fontSize+’px’ }”</p><h3 id="组件之间的传值通信"><a href="#组件之间的传值通信" class="headerlink" title="组件之间的传值通信"></a>组件之间的传值通信</h3><p><strong>父组件给子组件传值</strong></p><blockquote><p>使用props，父组件可以使用props向子组件传递数据</p></blockquote><p>父组件vue模板father.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child :msg&#x3D;&quot;message&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &#39;.&#x2F;child.vue&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message: &#39;father message&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>子组件vue模板child.vue:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            required: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>子组件向父组件通信</strong></p><blockquote><p>父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p></blockquote><p>父组件vue模板father.vue:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child @msgFunc&#x3D;&quot;func&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &#39;.&#x2F;child.vue&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        func (msg) &#123;</span><br><span class="line">            console.log(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>子组件vue模板child.vue:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;点我&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        msg: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            required: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods () &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            &#x2F;&#x2F;........</span><br><span class="line">            this.$emit(&#39;msgFunc&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>非父子，兄弟组件之间通信</strong></p><blockquote><p>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递</p></blockquote><p>Bus.js可以是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">export default new Vue()</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在需要通信的组件都引入Bus.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#39;..&#x2F;common&#x2F;js&#x2F;bus.js&#39;</span><br><span class="line">export default&#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">    toBus () &#123;</span><br><span class="line">        Bus.$emit(&#39;on&#39;, &#39;来自兄弟组件&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>另一个组件也import Bus.js 在钩子函数中监听on事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Bus from &#39;..&#x2F;common&#x2F;js&#x2F;bus.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">       Bus.$on(&#39;on&#39;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">         this.message &#x3D; msg</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="路由跳转方式"><a href="#路由跳转方式" class="headerlink" title="路由跳转方式"></a>路由跳转方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，&lt;router-link to&#x3D;&#39;home&#39;&gt; router-link标签会渲染为&lt;a&gt;标签，咋填template中的跳转都是这种；</span><br><span class="line"></span><br><span class="line">2，另一种是编程是导航 也就是通过js跳转 比如 router.push(&#39;&#x2F;home&#39;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</span><br><span class="line"></span><br><span class="line">V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</span><br><span class="line"></span><br><span class="line">VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="computed和watch有什么区别"><a href="#computed和watch有什么区别" class="headerlink" title="computed和watch有什么区别?"></a>computed和watch有什么区别?</h3><p><strong>computed:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. computed是计算属性,也就是计算值,它更多用于计算值的场景</span><br><span class="line">2. computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</span><br><span class="line">3. computed适用于计算比较消耗性能的计算场景</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>watch:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</span><br><span class="line">2. 无缓存性，页面重新渲染时值不变化也会执行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>小结:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</span><br><span class="line">2. 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速</p><p><strong>准确:</strong><br>如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来，会产生一系列的bug</p><p><strong>快速:</strong><br>key的唯一性可以被Map数据结构充分利用</p><h3 id="组件中的data为什么是函数？"><a href="#组件中的data为什么是函数？" class="headerlink" title="组件中的data为什么是函数？"></a>组件中的data为什么是函数？</h3><p>为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; data</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">message: &quot;子组件&quot;,</span><br><span class="line">childName:this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new Vue</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>因为组件是用来复用的，JS里对象是引用关系，这样作用域没有隔离，而new Vue的实例，是不会被复用的，因此不存在引用对象问题</p><h3 id="Class-与-Style-如何动态绑定？"><a href="#Class-与-Style-如何动态绑定？" class="headerlink" title="Class 与 Style 如何动态绑定？"></a>Class 与 Style 如何动态绑定？</h3><blockquote><p>Class 可以通过对象语法和数组语法进行动态绑定：</p></blockquote><p><strong>对象语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>数组语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#39;active&#39;,</span><br><span class="line">  errorClass: &#39;text-danger&#39;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p></blockquote><p><strong>对象语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#39;red&#39;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>数组语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style&#x3D;&quot;[styleColor, styleSize]&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">     color: &#39;red&#39;</span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:&#39;23px&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="vue的单项数据流"><a href="#vue的单项数据流" class="headerlink" title="vue的单项数据流"></a>vue的单项数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改</p><p>有两种常见的试图改变一个 prop 的情形 :</p><p>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用</p><blockquote><p>在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;initialCounter&#39;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这个 prop 以一种原始的值传入且需要进行转换</p><blockquote><p>在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;size&#39;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><h3 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h3><p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件;</li></ul><p>以 input 表单元素为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&#39;something&#39;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;ModelChild v-model&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ModelChild&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">    value: String</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">     this.$emit(&#39;input&#39;, &#39;小红&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick()"></a>nextTick()</h3><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改数据</span><br><span class="line">vm.msg &#x3D; &#39;Hello&#39;</span><br><span class="line">&#x2F;&#x2F; DOM 还未更新</span><br><span class="line">Vue.nextTick(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; DOM 更新</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="vue插槽"><a href="#vue插槽" class="headerlink" title="vue插槽"></a>vue插槽</h3><p>个人觉得这篇文章写的还可以：<a href="https://www.cnblogs.com/chinabin1993/p/9115396.html">www.cnblogs.com/chinabin199…</a></p><p><strong>单个插槽</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当子组件模板只有一个没有属性的插槽时，</span><br><span class="line">父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，</span><br><span class="line">并替换掉插槽标签本身</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>命名插槽</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solt元素可以用一个特殊的特性name来进一步配置如何分发内容。</span><br><span class="line">多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，</span><br><span class="line">和子组件 slot 元素产生关联，便于插槽内容对应传递</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>作用域插槽</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以访问组件内部数据的可复用插槽(reusable slot)</span><br><span class="line">在父级中，具有特殊特性 slot-scope 的&lt;template&gt; 元素必须存在，</span><br><span class="line">表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，</span><br><span class="line">此变量接收从子组件传递过来的 prop 对象</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="vue-router有哪几种导航钩子"><a href="#vue-router有哪几种导航钩子" class="headerlink" title="vue-router有哪几种导航钩子"></a>vue-router有哪几种导航钩子</h3><p>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截</p><p>第二种：组件内的钩子</p><p>第三种：单独路由独享组件</p><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><strong>vuex是什么？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</span><br><span class="line"></span><br><span class="line">state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</span><br><span class="line"></span><br><span class="line">它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p><p><strong>state</strong><br>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p><p><strong>mutations</strong><br>mutations定义的方法动态修改Vuex 的 store 中的状态或数据</p><p><strong>getters</strong><br>类似vue的计算属性，主要用来过滤一些数据</p><p><strong>action</strong><br>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</p><p><strong>总结</strong><br>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据</p><h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><p><strong>代码层面的优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v-if 和 v-show 区分使用场景</span><br><span class="line">computed 和 watch  区分使用场景</span><br><span class="line">v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</span><br><span class="line">长列表性能优化</span><br><span class="line">事件的销毁</span><br><span class="line">图片资源懒加载</span><br><span class="line">路由懒加载</span><br><span class="line">第三方插件的按需引入</span><br><span class="line">优化无限列表性能</span><br><span class="line">服务端渲染 SSR or 预渲染</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>Webpack 层面的优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Webpack 对图片进行压缩</span><br><span class="line">减少 ES6 转为 ES5 的冗余代码</span><br><span class="line">提取公共代码</span><br><span class="line">模板预编译</span><br><span class="line">提取组件的 CSS</span><br><span class="line">优化 SourceMap</span><br><span class="line">构建结果输出分析</span><br><span class="line">Vue 项目的编译优化</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>基础的 Web 技术的优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 gzip 压缩</span><br><span class="line">浏览器缓存</span><br><span class="line">CDN 的使用</span><br><span class="line">使用 Chrome Performance 查找性能瓶颈</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="var、let、const之间的区别"><a href="#var、let、const之间的区别" class="headerlink" title="var、let、const之间的区别"></a>var、let、const之间的区别</h3><p>var声明变量可以重复声明，而let不可以重复声明</p><p>var是不受限于块级的，而let是受限于块级</p><p>var会与window相映射（会挂一个属性），而let不与window相映射</p><p>var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错</p><p>const声明之后必须赋值，否则会报错</p><p>const定义不可变的量，改变了就会报错</p><p>const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p><strong>数组解构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] &#x3D; [1, 2, 3]   &#x2F;&#x2F;a&#x3D;1, b&#x3D;2, c&#x3D;3</span><br><span class="line">let [d, [e], f] &#x3D; [1, [2], 3]    &#x2F;&#x2F;嵌套数组解构 d&#x3D;1, e&#x3D;2, f&#x3D;3</span><br><span class="line">let [g, ...h] &#x3D; [1, 2, 3]   &#x2F;&#x2F;数组拆分 g&#x3D;1, h&#x3D;[2, 3]</span><br><span class="line">let [i,,j] &#x3D; [1, 2, 3]   &#x2F;&#x2F;不连续解构 i&#x3D;1, j&#x3D;3</span><br><span class="line">let [k,l] &#x3D; [1, 2, 3]   &#x2F;&#x2F;不完全解构 k&#x3D;1, l&#x3D;2</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>对象解构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123;a, b&#125; &#x3D; &#123;a: &#39;aaaa&#39;, b: &#39;bbbb&#39;&#125;      &#x2F;&#x2F;a&#x3D;&#39;aaaa&#39; b&#x3D;&#39;bbbb&#39;</span><br><span class="line">let obj &#x3D; &#123;d: &#39;aaaa&#39;, e: &#123;f: &#39;bbbb&#39;&#125;&#125;</span><br><span class="line">let &#123;d, e:&#123;f&#125;&#125; &#x3D; obj    &#x2F;&#x2F;嵌套解构 d&#x3D;&#39;aaaa&#39; f&#x3D;&#39;bbbb&#39;</span><br><span class="line">let g;</span><br><span class="line">(g &#x3D; &#123;g: &#39;aaaa&#39;&#125;)   &#x2F;&#x2F;以声明变量解构 g&#x3D;&#39;aaaa&#39;</span><br><span class="line">let [h, i, j, k] &#x3D; &#39;nice&#39;    &#x2F;&#x2F;字符串解构 h&#x3D;&#39;n&#39; i&#x3D;&#39;i&#39; j&#x3D;&#39;c&#39; k&#x3D;&#39;e&#39;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>函数参数的定义</strong></p><p>一般我们在定义函数的时候，如果函数有多个参数时，在es5语法中函数调用时参数必须一一对应，否则就会出现赋值错误的情况，来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function personInfo(name, age, address, gender) &#123;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(&#39;william&#39;, 18, &#39;changsha&#39;, &#39;man&#39;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function personInfo(&#123;name, age, address, gender&#125;) &#123;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(&#123;gender: &#39;man&#39;, address: &#39;changsha&#39;, name: &#39;william&#39;, age: 18&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这么写我们只知道要传声明参数就行来，不需要知道参数的顺序也没关系</p><p><strong>交换变量的值</strong></p><p>在es5中我们需要交换两个变量的值需要借助临时变量的帮助，来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;1, b&#x3D;2, c</span><br><span class="line">c &#x3D; a</span><br><span class="line">a &#x3D; b</span><br><span class="line">b &#x3D; c</span><br><span class="line">console.log(a, b)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>来看es6怎么实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a&#x3D;1, b&#x3D;2;</span><br><span class="line">[b, a] &#x3D; [a, b]</span><br><span class="line">console.log(a, b)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>是不是比es5的写法更加方便呢</p><p><strong>函数默认参数</strong></p><p>在日常开发中，经常会有这种情况：函数的参数需要默认值，如果没有默认值在使用的时候就会报错，来看es5中是怎么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function saveInfo(name, age, address, gender) &#123;</span><br><span class="line">  name &#x3D; name || &#39;william&#39;</span><br><span class="line">  age &#x3D; age || 18</span><br><span class="line">  address &#x3D; address || &#39;changsha&#39;</span><br><span class="line">  gender &#x3D; gender || &#39;man&#39;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在函数离 main先对参数做一个默认值赋值，然后再使用避免使用的过程中报错，再来看es6中的使用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function saveInfo(&#123;name&#x3D; &#39;william&#39;, age&#x3D; 18, address&#x3D; &#39;changsha&#39;, gender&#x3D; &#39;man&#39;&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  console.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在函数定义的时候就定义了默认参数，这样就免了后面给参数赋值默认值的过程，是不是看起来简单多了</p><h3 id="forEach、for-in、for-of三者区别"><a href="#forEach、for-in、for-of三者区别" class="headerlink" title="forEach、for in、for of三者区别"></a>forEach、for in、for of三者区别</h3><p>forEach更多的用来遍历数</p><p>for in 一般常用来遍历对象或json</p><p>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()</p><p>for in循环出的是key，for of循环出的是value</p><h3 id="使用箭头函数应注意什么？"><a href="#使用箭头函数应注意什么？" class="headerlink" title="使用箭头函数应注意什么？"></a>使用箭头函数应注意什么？</h3><p>1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）<br>2、不能够使用arguments对象<br>3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误<br>4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p><h3 id="Set、Map的区别"><a href="#Set、Map的区别" class="headerlink" title="Set、Map的区别"></a>Set、Map的区别</h3><p>应用场景Set用于数据重组，Map用于数据储存</p><p><strong>Set：</strong><br>1，成员不能重复<br>2，只有键值没有键名，类似数组<br>3，可以遍历，方法有add, delete,has</p><p><strong>Map:</strong><br>1，本质上是健值对的集合，类似集合<br>2，可以遍历，可以跟各种数据格式转换</p><h3 id="promise对象的用法-手写一个promise"><a href="#promise对象的用法-手写一个promise" class="headerlink" title="promise对象的用法,手写一个promise"></a>promise对象的用法,手写一个promise</h3><p>promise是一个构造函数，下面是一个简单实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var promise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (操作成功) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;,function (value) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="如何创建一个ajax"><a href="#如何创建一个ajax" class="headerlink" title="如何创建一个ajax"></a>如何创建一个ajax</h3><p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br>(3)设置响应HTTP请求状态变化的函数<br>(4)发送HTTP请求<br>(5)获取异步调用返回的数据<br>(6)使用JavaScript和DOM实现局部刷新</p><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><p><strong>同步：</strong><br>浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</p><p><strong>异步：</strong><br>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</p><h3 id="ajax的优点和缺点"><a href="#ajax的优点和缺点" class="headerlink" title="ajax的优点和缺点"></a>ajax的优点和缺点</h3><p><strong>ajax的优点</strong></p><p>1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）<br>2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）<br>3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）<br>4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）</p><p><strong>ajax的缺点</strong></p><p>1、ajax不支持浏览器back按钮<br>2、安全问题 Aajax暴露了与服务器交互的细节<br>3、对搜索引擎的支持比较弱<br>4、破坏了Back与History后退按钮的正常行为等浏览器机制</p><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p>1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些 2、get相对post安全性低<br>3、get有缓存，post没有<br>4、get体积小，post可以无限大<br>5、get的url参数可见，post不可见<br>6、get只接受ASCII字符的参数数据类型，post没有限制<br>7、get请求参数会保留历史记录，post中参数不会保留<br>8、get会被浏览器主动catch，post不会，需要手动设置<br>9、get在浏览器回退时无害，post会再次提交请求</p><p><strong>什么时候使用post？</strong></p><p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如</p><p>1、无法使用缓存文件（更新服务器上的文件或数据库）<br>2、向服务器发送大量数据（POST 没有数据量限制）<br>3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p><strong>解决跨域问题：</strong></p><p>1、使用JSONP（json+padding）把数据内填充起来<br>2、CORS方式（跨域资源共享），在后端上配置可跨域<br>3、服务器代理，通过服务器的文件能访问第三方资源</p><h3 id="什么是Ajax和JSON，它们的优点和缺点"><a href="#什么是Ajax和JSON，它们的优点和缺点" class="headerlink" title="什么是Ajax和JSON，它们的优点和缺点"></a>什么是Ajax和JSON，它们的优点和缺点</h3><p><strong>Ajax：</strong></p><p>Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互</p><p><strong>Ajax优点：</strong></p><p>异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；</p><p><strong>Ajax缺点：</strong></p><p>异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</p><p><strong>JSON：</strong></p><p>是一种轻量级的数据交换格式，看着像对象，本质是字符串</p><p><strong>JSON优点：</strong></p><p>轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型</p><p><strong>JSON缺点：</strong></p><p>没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="git常用的命令"><a href="#git常用的命令" class="headerlink" title="git常用的命令"></a>git常用的命令</h3><p>从远程库克隆到本地：git clone 网站上的仓库地址</p><p>新增文件的命令：git add .</p><p>提交文件的命令：git commit –m或者git commit –a</p><p>查看工作区状况：git status –s</p><p>拉取合并远程分支的操作：git fetch/git merge或者git pull</p><p>查看提交记录命令：git reflog</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="webpack打包原理"><a href="#webpack打包原理" class="headerlink" title="webpack打包原理"></a>webpack打包原理</h3><p>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的 入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。webpack做的就是分析代码。转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)</p><h3 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h3><p>模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器</p><blockquote><p>devServer中通过hot属性可以控制模块的热替换</p></blockquote><p><strong>通过配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const webpack &#x3D; require(&#39;webpack&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">let env &#x3D; process.env.NODE_ENV &#x3D;&#x3D; &quot;development&quot; ? &quot;development&quot; : &quot;production&quot;;</span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">  mode: env,</span><br><span class="line"> devServer: &#123;</span><br><span class="line">     hot:true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  plugins: [</span><br><span class="line">     new webpack.HotModuleReplacementPlugin(), &#x2F;&#x2F;热加载插件</span><br><span class="line">  ],</span><br><span class="line">module.exports &#x3D; config;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>通过命令行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">   &quot;start&quot;: &quot;NODE_ENV&#x3D;development  webpack-dev-server --config  webpack.develop.config.js --hot&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="如何提高webpack构建速度"><a href="#如何提高webpack构建速度" class="headerlink" title="如何提高webpack构建速度"></a>如何提高webpack构建速度</h3><p>1、通过externals配置来提取常用库</p><p>2、利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来</p><p>3、使用Happypack 实现多线程加速编译</p><p>要注意的第一点是，它对file-loader和url-loader支持不好，所以这两个loader就不需要换成happypack了，其他loader可以类似地换一下</p><p>4、使用Tree-shaking和Scope Hoisting来剔除多余代码 5、使用fast-sass-loader代替sass-loader 6、babel-loader开启缓存</p><p>babel-loader在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译效率 可以加上cacheDirectory参数或使用 transform-runtime 插件试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.config.js</span><br><span class="line">use: [&#123;</span><br><span class="line">    loader: &#39;babel-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">        cacheDirectory: true</span><br><span class="line">&#125;]</span><br><span class="line">&#x2F;&#x2F; .bablerc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>不需要打包编译的插件库换成全局”script”标签引入的方式</p><p>比如jQuery插件，react, react-dom等，代码量是很多的，打包起来可能会很耗时 可以直接用标签引入，然后在webpack配置里使用 expose-loader 或 externals 或 ProvidePlugin 提供给模块内部使用相应的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @1</span><br><span class="line">use: [&#123;</span><br><span class="line">    loader: &#39;expose-loader&#39;,</span><br><span class="line">    options: &#39;$&#39;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">    loader: &#39;expose-loader&#39;,</span><br><span class="line">    options: &#39;jQuery&#39;</span><br><span class="line">    &#125;]</span><br><span class="line">&#x2F;&#x2F; @2</span><br><span class="line">externals: &#123;</span><br><span class="line">        jquery: &#39;jQuery&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">&#x2F;&#x2F; @3</span><br><span class="line">        new webpack.ProvidePlugin(&#123;</span><br><span class="line">            $: &#39;jquery&#39;,</span><br><span class="line">            jQuery: &#39;jquery&#39;,</span><br><span class="line">            &#39;window.jQuery&#39;: &#39;jquery&#39;</span><br><span class="line">        &#125;),</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>8、优化构建时的搜索路径</p><p>在webpack打包时，会有各种各样的路径要去查询搜索，我们可以加上一些配置，让它搜索地更快 比如说，方便改成绝对路径的模块路径就改一下，以纯模块名来引入的可以加上一些目录路径 还可以善于用下resolve alias别名 这个字段来配置 还有exclude等的配置，避免多余查找的文件，比如使用babel别忘了剔除不需要遍历的</p><h3 id="webpack的优点"><a href="#webpack的优点" class="headerlink" title="webpack的优点"></a>webpack的优点</h3><p>专注于处理模块化的项目，能做到开箱即用，一步到位</p><p>可通过plugin扩展，完整好用又不失灵活</p><p>使用场景不局限于web开发</p><p>社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展</p><p>良好的开发体验</p><h3 id="webpack的缺点"><a href="#webpack的缺点" class="headerlink" title="webpack的缺点"></a>webpack的缺点</h3><p>webpack的缺点是只能用于采用模块化开发的项目</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>目前网络分层可分为两种：OSI 模型和 TCP/IP 模型</p><p><strong>OSI模型</strong><br>应用层（Application）<br>表示层（Presentation）<br>会话层（Session）<br>传输层（Transport）<br>网络层（Network）<br>数据链路层（Data Link）<br>物理层（Physical）</p><p><strong>TCP/IP模型</strong><br>应用层（Application）<br>传输层（Host-to-Host Transport）<br>互联网层（Internet）<br>网络接口层（Network Interface）</p><h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>区分状态码</strong><br>1××开头 - 信息提示<br>2××开头 - 请求成功<br>3××开头 - 请求被重定向<br>4××开头 - 请求错误<br>5××开头 - 服务器错误</p><p><strong>常见状态码</strong><br>200 - 请求成功，Ajax 接受到信息了<br>400 - 服务器不理解请求<br>403 - 服务器拒绝请求<br>404 - 请求页面错误<br>500 - 服务器内部错误，无法完成请求</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="HTML优化"><a href="#HTML优化" class="headerlink" title="HTML优化"></a>HTML优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、避免 HTML 中书写 CSS 代码，因为这样难以维护。</span><br><span class="line">2、使用 Viewport 加速页面的渲染。</span><br><span class="line">3、使用语义化标签，减少 CSS 代码，增加可读性和 SEO。</span><br><span class="line">4、减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。</span><br><span class="line">5、避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</span><br><span class="line">6、减少 DNS 查询的次数</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a>CSS优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、优化选择器路径：使用 .c &#123;&#125; 而不是 .a .b .c &#123;&#125;。</span><br><span class="line">2、选择器合并：共同的属性内容提起出来，压缩空间和资源开销。</span><br><span class="line">3、精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。</span><br><span class="line">4、雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。</span><br><span class="line">5、避免通配符：.a .b * &#123;&#125; 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符 * &#123;&#125; 6、会遍历整个 DOM，性能大大损耗。</span><br><span class="line">7、少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。</span><br><span class="line">8、为 0 值去单位：增加兼容性。</span><br><span class="line">9、压缩文件大小，减少资源下载负担。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="JavaScript优化"><a href="#JavaScript优化" class="headerlink" title="JavaScript优化"></a>JavaScript优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、尽可能把 &lt;script&gt; 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来</span><br><span class="line">2、尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……</span><br><span class="line">3、CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。</span><br><span class="line">4、尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。</span><br><span class="line">5、尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。</span><br><span class="line">6、压缩文件大小，减少资源下载负担。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="面试常见的其他问题"><a href="#面试常见的其他问题" class="headerlink" title="面试常见的其他问题"></a>面试常见的其他问题</h2><h3 id="常问"><a href="#常问" class="headerlink" title="常问"></a>常问</h3><p>1、自我介绍<br>2、你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？<br>3、你认为哪个项目做得最好？<br>4、平时是如何学习前端开发的？<br>5、你最有成就感的一件事<br>6、你是怎么学习前端的</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>谈谈你对重构的理解？</strong></p><p>网络重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI</p><p>对于传统的网站来说重构通常是：</p><ul><li>表格(table)布局改为DIV+CSS</li><li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li><li>对于移动平台的优化</li><li>针对于SEO进行优化</li></ul><p><strong>什么样的前端代码是好的？</strong></p><p>高复用低耦合，这样文件小，好维护，而且好扩展</p><p><strong>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</strong></p><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近</p><ul><li>实现界面交互</li><li>提升用户体验</li><li>有了Node.js，前端可以实现服务端的一些事情</li></ul><p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</p><p>与团队成员，UI设计，产品经理的沟通；</p><p>做好的页面结构，页面重构和用户体验；</p><p><strong>你觉得前端工程的价值体现在哪？</strong></p><p>1、为简化用户使用提供技术支持（交互部分）<br>2、为多个浏览器兼容性提供支持<br>3、为提高用户浏览速度（浏览器性能）提供支持<br>4、为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持<br>5、为展示数据提供支持（数据接口）</p><p><strong>平时如何管理你的项目？</strong></p><ul><li><p>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；</p></li><li><p>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</p></li><li><p>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</p></li><li><p>页面进行标注（例如 页面 模块 开始和结束）；</p></li><li><p>CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；</p></li><li><p>JS 分文件夹存放 命名以该JS功能为准的英文翻译。</p></li><li><p>图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/vue-zong-jie/"/>
      <url>/2020/09/07/vue-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="史上最强vue总结-万字长文—面试开发全靠它了"><a href="#史上最强vue总结-万字长文—面试开发全靠它了" class="headerlink" title="史上最强vue总结~万字长文—面试开发全靠它了"></a>史上最强vue总结~万字长文—面试开发全靠它了</h1><h2 id="vue框架篇"><a href="#vue框架篇" class="headerlink" title="vue框架篇"></a>vue框架篇</h2><h3 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p><p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p><p>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p><h3 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h3><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><blockquote><p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</p></blockquote><blockquote><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p></blockquote><blockquote><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p></blockquote><blockquote><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p></blockquote><h3 id="为什么vue组件中data必须是一个函数？"><a href="#为什么vue组件中data必须是一个函数？" class="headerlink" title="为什么vue组件中data必须是一个函数？"></a>为什么vue组件中data必须是一个函数？</h3><p>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p><h3 id="vue中v-if和v-show有什么区别？"><a href="#vue中v-if和v-show有什么区别？" class="headerlink" title="vue中v-if和v-show有什么区别？"></a>vue中v-if和v-show有什么区别？</h3><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p><p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p><p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="计算属性computed："><a href="#计算属性computed：" class="headerlink" title="计算属性computed："></a>计算属性computed：</h4><ul><li><p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p></li><li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p></li><li><p>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p></li><li><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p></li><li><p>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p></li></ul><h4 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a>侦听属性watch：</h4><ul><li><p>不支持缓存，数据变，直接会触发相应的操作；</p></li><li><p>watch支持异步；</p></li><li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li><li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p></li><li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</p></li></ul><blockquote><p>immediate：组件加载立即触发回调函数执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#96;watch: &#123;</span><br><span class="line"> firstName: &#123;</span><br><span class="line"> handler(newName, oldName) &#123;</span><br><span class="line"> this.fullName &#x3D; newName + &#39; &#39; + this.lastName;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#x2F;&#x2F; 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span><br><span class="line"> immediate: true</span><br><span class="line"> &#125;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><blockquote><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#96;watch: &#123;</span><br><span class="line"> obj: &#123;</span><br><span class="line"> handler(newName, oldName) &#123;</span><br><span class="line"> console.log(&#39;obj.a changed&#39;);</span><br><span class="line"> &#125;,</span><br><span class="line"> immediate: true,</span><br><span class="line"> deep: true</span><br><span class="line"> &#125;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>优化：我们可以使用字符串的形式监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#96;watch: &#123;</span><br><span class="line"> &#39;obj.a&#39;: &#123;</span><br><span class="line"> handler(newName, oldName) &#123;</span><br><span class="line"> console.log(&#39;obj.a changed&#39;);</span><br><span class="line"> &#125;,</span><br><span class="line"> immediate: true,</span><br><span class="line"> &#x2F;&#x2F; deep: true</span><br><span class="line"> &#125;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p><h3 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h3><p>vue文件的一个加载器，跟template/js/style转换成js模块。</p><h3 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p><blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote><h3 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h3><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p><p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><h3 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><blockquote><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></blockquote><blockquote><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote><blockquote><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></blockquote><blockquote><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote><h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><p>通过props传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;父组件： &lt;child value &#x3D; &#39;传递的数据&#39; &#x2F;&gt;</span><br><span class="line"> 子组件: props[&#39;value&#39;],接收数据,接受之后使用和data中定义数据使用方式一样 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;父组件： &lt;child @receive &#x3D; &#39;receive&#39; &#x2F;&gt;</span><br><span class="line"> 子组件: this.$emit(&#39;receive&#39;,&#39;传递的数据&#39;) 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h4><ul><li>通过中央通信 let bus = new Vue()</li></ul><blockquote><p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p></blockquote><blockquote><p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p></blockquote><ul><li>通过vuex</li></ul><h3 id="prop-验证，和默认值"><a href="#prop-验证，和默认值" class="headerlink" title="prop 验证，和默认值"></a>prop 验证，和默认值</h3><p>我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#96;props: &#123;</span><br><span class="line"> visible: &#123;</span><br><span class="line"> default: true,</span><br><span class="line"> type: Boolean,</span><br><span class="line"> required: true</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;, 复制代码&#96;</span><br></pre></td></tr></table></figure><h3 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="headerlink" title="请说下封装 vue 组件的过程"></a>请说下封装 vue 组件的过程</h3><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p><p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p><h3 id="Vue-js的template编译"><a href="#Vue-js的template编译" class="headerlink" title="Vue.js的template编译"></a>Vue.js的template编译</h3><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：</p><blockquote><p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p></blockquote><blockquote><p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p></blockquote><h3 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h3><p>css的预编译,使用步骤如下：</p><p>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</p><p>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</p><p>第三步：还是在同一个文件，配置一个module属性</p><p>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</p><p>特性主要有:</p><ul><li><p>可以用变量，例如（$变量名称=值）</p></li><li><p>可以用混合器，例如（）</p></li><li><p>可以嵌套</p></li></ul><h3 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;this.$set(this.arr, 0, &quot;OBKoro1&quot;); &#x2F;&#x2F; 改变数组</span><br><span class="line">this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); &#x2F;&#x2F; 改变对象 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p><h3 id="常用的事件修饰符"><a href="#常用的事件修饰符" class="headerlink" title="常用的事件修饰符"></a>常用的事件修饰符</h3><ul><li><p>.stop:阻止冒泡</p></li><li><p>.prevent:阻止默认行为</p></li><li><p>.self:仅绑定元素自身触发</p></li><li><p>.once: 2.1.4 新增,只触发一次</p></li><li><p>passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</p></li><li><p>.sync 修饰符</p></li></ul><p>从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&lt;comp :foo.sync&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;comp&gt;</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&lt;comp :foo&#x3D;&quot;bar&quot; @update:foo&#x3D;&quot;val &#x3D;&gt; bar &#x3D; val&quot;&gt;&lt;&#x2F;comp&gt;</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;this.$emit(&#39;update:foo&#39;, newValue)</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><h3 id="vue如何获取dom"><a href="#vue如何获取dom" class="headerlink" title="vue如何获取dom"></a>vue如何获取dom</h3><p>先给标签设置一个ref值，再通过this.$refs.domName获取，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&lt;div ref&#x3D;&quot;test&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> const dom &#x3D; this.$refs.test 复制代码&#96;</span><br></pre></td></tr></table></figure><h3 id="v-on可以监听多个方法吗？"><a href="#v-on可以监听多个方法吗？" class="headerlink" title="v-on可以监听多个方法吗？"></a>v-on可以监听多个方法吗？</h3><p>是可以的，来个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&lt;input type&#x3D;&quot;text&quot; v-on&#x3D;&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><h3 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h3><p>这两个都是用来存放项目中所使用的静态资源文件。</p><p>两者的区别：</p><p>assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p><p>static中的文件则不会被打包。</p><blockquote><p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p></blockquote><h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p><h3 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;[v-cloak] &#123;</span><br><span class="line"> display: none;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上style=”display: none;” :style=”{display: ‘block’}”</p><h2 id="vue插件篇"><a href="#vue插件篇" class="headerlink" title="vue插件篇"></a>vue插件篇</h2><h3 id="状态管理（vuex）"><a href="#状态管理（vuex）" class="headerlink" title="状态管理（vuex）"></a>状态管理（vuex）</h3><h4 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h4><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><h4 id="怎么使用vuex"><a href="#怎么使用vuex" class="headerlink" title="怎么使用vuex"></a>怎么使用vuex</h4><p>第一步安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;npm install vuex -S</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><p>第二步创建store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#96;import Vue from &#39;vue&#39;;</span><br><span class="line">import Vuex from &#39;vuex&#39;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">&#x2F;&#x2F;不是在生产环境debug为true</span><br><span class="line">const debug &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;;</span><br><span class="line">&#x2F;&#x2F;创建Vuex实例对象</span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> strict:debug,&#x2F;&#x2F;在不是生产环境下都开启严格模式</span><br><span class="line"> state:&#123;</span><br><span class="line"> &#125;,</span><br><span class="line"> getters:&#123;</span><br><span class="line"> &#125;,</span><br><span class="line"> mutations:&#123;</span><br><span class="line"> &#125;,</span><br><span class="line"> actions:&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default store; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>第三步注入vuex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#96;import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">const vm &#x3D; new Vue(&#123;</span><br><span class="line"> store:store,</span><br><span class="line"> render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;) 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="vuex中有几个核心属性，分别是什么？"><a href="#vuex中有几个核心属性，分别是什么？" class="headerlink" title="vuex中有几个核心属性，分别是什么？"></a>vuex中有几个核心属性，分别是什么？</h4><p>一共有5个核心属性，分别是:</p><ul><li><p>state 唯一数据源,Vue 实例中的 data 遵循相同的规则</p></li><li><p>getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#96;const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> state: &#123;</span><br><span class="line"> todos: [</span><br><span class="line"> &#123; id: 1, text: &#39;...&#39;, done: true &#125;,</span><br><span class="line"> &#123; id: 2, text: &#39;...&#39;, done: false &#125;</span><br><span class="line"> ]</span><br><span class="line"> &#125;,</span><br><span class="line"> getters: &#123;</span><br><span class="line"> doneTodos: state &#x3D;&gt; &#123;</span><br><span class="line"> return state.todos.filter(todo &#x3D;&gt; todo.done)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> store.getters.doneTodos &#x2F;&#x2F; -&gt; [&#123; id: 1, text: &#39;...&#39;, done: true &#125;] 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> state: &#123;</span><br><span class="line"> count: 1</span><br><span class="line"> &#125;,</span><br><span class="line"> mutations: &#123;</span><br><span class="line"> increment (state) &#123;</span><br><span class="line"> &#x2F;&#x2F; 变更状态</span><br><span class="line"> state.count++</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> store.commit(&#39;increment&#39;) 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#96;const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> state: &#123;</span><br><span class="line"> count: 0</span><br><span class="line"> &#125;,</span><br><span class="line"> mutations: &#123;</span><br><span class="line"> increment (state) &#123;</span><br><span class="line"> state.count++</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> actions: &#123;</span><br><span class="line"> increment (context) &#123;</span><br><span class="line"> context.commit(&#39;increment&#39;)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;) 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>module 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#96;const moduleA &#x3D; &#123;</span><br><span class="line"> state: () &#x3D;&gt; (&#123; ... &#125;),</span><br><span class="line"> mutations: &#123; ... &#125;,</span><br><span class="line"> actions: &#123; ... &#125;,</span><br><span class="line"> getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"> const moduleB &#x3D; &#123;</span><br><span class="line"> state: () &#x3D;&gt; (&#123; ... &#125;),</span><br><span class="line"> mutations: &#123; ... &#125;,</span><br><span class="line"> actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"> const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> modules: &#123;</span><br><span class="line"> a: moduleA,</span><br><span class="line"> b: moduleB</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class="line">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#ajax请求代码应该写在组件的methods中还是vuex的actions中" class="headerlink" title="ajax请求代码应该写在组件的methods中还是vuex的actions中"></a>ajax请求代码应该写在组件的methods中还是vuex的actions中</h4><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p><p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p><h4 id="从vuex中获取的数据能直接更改吗？"><a href="#从vuex中获取的数据能直接更改吗？" class="headerlink" title="从vuex中获取的数据能直接更改吗？"></a>从vuex中获取的数据能直接更改吗？</h4><p>从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；</p><h4 id="vuex中的数据在页面刷新后数据消失"><a href="#vuex中的数据在页面刷新后数据消失" class="headerlink" title="vuex中的数据在页面刷新后数据消失"></a>vuex中的数据在页面刷新后数据消失</h4><p>用sessionstorage 或者 localstorage 存储数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;存储： sessionStorage.setItem( &#39;名&#39;, JSON.stringify(值) )</span><br><span class="line">使用： sessionStorage.getItem(&#39;名&#39;) ---得到的值为字符串类型，用JSON.parse()去引号； 复制代码&#96;</span><br></pre></td></tr></table></figure><p>也可以引入插件vuex-persist，使用方法如下：</p><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;npm install --save vuex-persist</span><br><span class="line">or</span><br><span class="line">yarn add vuex-persist 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>引入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;import VuexPersistence from &#39;vuex-persist&#39;</span><br><span class="line">复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>先创建一个对象并进行配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;const vuexLocal &#x3D; new VuexPersistence(&#123;</span><br><span class="line"> storage: window.localStorage</span><br><span class="line">&#125;) 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>引入进vuex插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> state: &#123; ... &#125;,</span><br><span class="line"> mutations: &#123; ... &#125;,</span><br><span class="line"> actions: &#123; ... &#125;,</span><br><span class="line"> plugins: [vuexLocal.plugin]</span><br><span class="line">&#125;) 复制代码&#96;</span><br></pre></td></tr></table></figure><p>通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。</p><h4 id="Vuex的严格模式是什么-有什么作用-怎么开启？"><a href="#Vuex的严格模式是什么-有什么作用-怎么开启？" class="headerlink" title="Vuex的严格模式是什么,有什么作用,怎么开启？"></a>Vuex的严格模式是什么,有什么作用,怎么开启？</h4><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line"> strict:true,</span><br><span class="line">&#125;) 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="怎么在组件中批量使用Vuex的getter属性"><a href="#怎么在组件中批量使用Vuex的getter属性" class="headerlink" title="怎么在组件中批量使用Vuex的getter属性"></a>怎么在组件中批量使用Vuex的getter属性</h4><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;import &#123;mapGetters&#125; from &#39;vuex&#39;</span><br><span class="line">export default&#123;</span><br><span class="line"> computed:&#123;</span><br><span class="line"> ...mapGetters([&#39;total&#39;,&#39;discountTotal&#39;])</span><br><span class="line"> &#125;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="组件中重复使用mutation"><a href="#组件中重复使用mutation" class="headerlink" title="组件中重复使用mutation"></a>组件中重复使用mutation</h4><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;import &#123; mapMutations &#125; from &#39;vuex&#39;</span><br><span class="line">methods:&#123;</span><br><span class="line"> ...mapMutations(&#123;</span><br><span class="line"> setNumber:&#39;SET_NUMBER&#39;,</span><br><span class="line"> &#125;)</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>然后调用this.setNumber(10)相当调用this.$store.commit(‘SET_NUMBER’,10)</p><h4 id="mutation和action有什么区别"><a href="#mutation和action有什么区别" class="headerlink" title="mutation和action有什么区别"></a>mutation和action有什么区别</h4><ul><li><p>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</p></li><li><p>action 可以包含任意异步操作。mutation只能是同步操作</p></li><li><p>提交方式不同</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;action 是用this.store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。</span><br><span class="line">mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交 复制代码&#96;</span><br></pre></td></tr></table></figure><ul><li>接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#123;</span><br><span class="line"> state,      &#x2F;&#x2F; 等同于 &#96;store.state&#96;，若在模块中则为局部状态</span><br><span class="line"> rootState,  &#x2F;&#x2F; 等同于 &#96;store.state&#96;，只存在于模块中</span><br><span class="line"> commit,     &#x2F;&#x2F; 等同于 &#96;store.commit&#96;</span><br><span class="line"> dispatch,   &#x2F;&#x2F; 等同于 &#96;store.dispatch&#96;</span><br><span class="line"> getters,    &#x2F;&#x2F; 等同于 &#96;store.getters&#96;</span><br><span class="line"> rootGetters &#x2F;&#x2F; 等同于 &#96;store.getters&#96;，只存在于模块中</span><br><span class="line">&#125; 复制代码&#96;&#96;</span><br></pre></td></tr></table></figure><h4 id="在v-model上怎么用Vuex中state的值？"><a href="#在v-model上怎么用Vuex中state的值？" class="headerlink" title="在v-model上怎么用Vuex中state的值？"></a>在v-model上怎么用Vuex中state的值？</h4><p>需要通过computed计算属性来转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&lt;input v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">computed: &#123;</span><br><span class="line"> message: &#123;</span><br><span class="line"> get () &#123;</span><br><span class="line"> return this.$store.state.message</span><br><span class="line"> &#125;,</span><br><span class="line"> set (value) &#123;</span><br><span class="line"> this.$store.commit(&#39;updateMessage&#39;, value)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><h3 id="路由页面管理（vue-router）"><a href="#路由页面管理（vue-router）" class="headerlink" title="路由页面管理（vue-router）"></a>路由页面管理（vue-router）</h3><h4 id="什么是vue-router"><a href="#什么是vue-router" class="headerlink" title="什么是vue-router"></a>什么是vue-router</h4><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li><p>嵌套的路由/视图表</p></li><li><p>模块化的、基于组件的路由配置</p></li><li><p>路由参数、查询、通配符</p></li><li><p>基于 Vue.js 过渡系统的视图过渡效果</p></li><li><p>细粒度的导航控制</p></li><li><p>带有自动激活的 CSS class 的链接</p></li><li><p>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</p></li><li><p>自定义的滚动条行为</p></li></ul><h4 id="怎么使用vue-router"><a href="#怎么使用vue-router" class="headerlink" title="怎么使用vue-router"></a>怎么使用vue-router</h4><p>第一步安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;npm install vue-router -S</span><br><span class="line">  复制代码&#96;</span><br></pre></td></tr></table></figure><p>第二步在main.js中使用Vue Router组件</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734d65dc240568e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>第三步配置路由</p><ul><li>定义 (路由) 组件</li></ul><p>路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734d65dc2668cc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>定义路由（路由对象数组）</li></ul><p>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734d65dc3da62ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>实例化Vue Router对象</li></ul><p>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734d65dc48e8bf4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>挂载根实例</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734d65dcb5f42d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>第四步在App.vue中使用路由</p><p>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/14/1734d65dc512c1e6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</p><h4 id="vue-router的导航钩子"><a href="#vue-router的导航钩子" class="headerlink" title="vue-router的导航钩子"></a>vue-router的导航钩子</h4><p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p><ul><li><p>全局导航钩子：router.beforeEach(to,from,next)</p></li><li><p>组件内的钩子</p></li><li><p>单独路由独享组件</p></li></ul><h4 id="vue路由传参"><a href="#vue路由传参" class="headerlink" title="vue路由传参"></a>vue路由传参</h4><blockquote><p>使用query方法传入的参数使用this.$route.query接受</p></blockquote><blockquote><p>使用params方式传入的参数使用this.$route.params接受</p></blockquote><h4 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h4><blockquote><p>route为当前router跳转对象里面可以获取name、path、query、params等</p></blockquote><blockquote><p>router为VueRouter实例，想要导航到不同URL，则使用router.push方法</p></blockquote><h4 id="路由-TypeError-Cannot-read-property-‘matched’-of-undefined-的错误问题"><a href="#路由-TypeError-Cannot-read-property-‘matched’-of-undefined-的错误问题" class="headerlink" title="路由 TypeError: Cannot read property ‘matched’ of undefined 的错误问题"></a>路由 TypeError: Cannot read property ‘matched’ of undefined 的错误问题</h4><p>找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#x2F;&#x2F; 引入路由</span><br><span class="line">import router from &#39;.&#x2F;routers&#x2F;router.js&#39;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line"> el: &#39;#app&#39;,</span><br><span class="line"> router,    &#x2F;&#x2F; 这个名字必须使用router</span><br><span class="line"> render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;); 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="路由按需加载"><a href="#路由按需加载" class="headerlink" title="路由按需加载"></a>路由按需加载</h4><p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;webpack&lt; 2.4 时</span><br><span class="line">&#123; </span><br><span class="line"> path:&#39;&#x2F;&#39;, </span><br><span class="line"> name:&#39;home&#39;,</span><br><span class="line"> components:resolve&#x3D;&gt;require([&#39;@&#x2F;components&#x2F;home&#39;],resolve)</span><br><span class="line">&#125; </span><br><span class="line">webpack&gt; 2.4 时</span><br><span class="line">&#123; </span><br><span class="line"> path:&#39;&#x2F;&#39;, </span><br><span class="line"> name:&#39;home&#39;, </span><br><span class="line"> components:()&#x3D;&gt;import(&#39;@&#x2F;components&#x2F;home&#39;)</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p><h4 id="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"><a href="#Vue里面router-link在电脑上有用，在安卓上没反应怎么解决" class="headerlink" title="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"></a>Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4><p>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决</p><h4 id="Vue2中注册在router-link上事件无效解决方法"><a href="#Vue2中注册在router-link上事件无效解决方法" class="headerlink" title="Vue2中注册在router-link上事件无效解决方法"></a>Vue2中注册在router-link上事件无效解决方法</h4><p>使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件</p><h4 id="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"><a href="#RouterLink在IE和Firefox中不起作用（路由不跳转）的问题" class="headerlink" title="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"></a>RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h4><ul><li><p>只用a标签，不使用button标签</p></li><li><p>使用button标签和Router.navigate方法</p></li></ul><h3 id="网络请求-axios"><a href="#网络请求-axios" class="headerlink" title="网络请求(axios)"></a>网络请求(axios)</h3><p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p><p><a href="https://juejin.im/post/5f04095e5188252e4a27e31c">学会了axios封装，世界都是你的</a></p><h3 id="视频播放-video-js"><a href="#视频播放-video-js" class="headerlink" title="视频播放(video.js)"></a>视频播放(video.js)</h3><p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p><p><a href="https://juejin.im/post/5f0bfa2de51d4534c243a124">手把手从零开始—封装一个vue视频播放器组件</a></p><h3 id="vue常用ui库"><a href="#vue常用ui库" class="headerlink" title="vue常用ui库"></a>vue常用ui库</h3><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><ul><li><p>mint-ui （<a href="http://mint-ui.github.io/#!/zh-cn%EF%BC%89">http://mint-ui.github.io/#!/zh-cn）</a></p></li><li><p>Vant（<a href="https://youzan.github.io/vant/#/zh-CN/home%EF%BC%89">https://youzan.github.io/vant/#/zh-CN/home）</a></p></li><li><p>VUX (<a href="https://vux.li/">https://vux.li/</a>)</p></li></ul><h4 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h4><ul><li><p>element-ui（<a href="https://element.eleme.cn/2.13/#/zh-CN/component/installation%EF%BC%89">https://element.eleme.cn/2.13/#/zh-CN/component/installation）</a></p></li><li><p>Ant Design of Vue（<a href="https://www.antdv.com/docs/vue/introduce-cn/%EF%BC%89">https://www.antdv.com/docs/vue/introduce-cn/）</a></p></li><li><p>Avue (<a href="https://avuejs.com/">https://avuejs.com/</a>)</p></li></ul><h2 id="常用webpack配置"><a href="#常用webpack配置" class="headerlink" title="常用webpack配置"></a>常用webpack配置</h2><h3 id="vue-lic3脚手架（vue-config-js）"><a href="#vue-lic3脚手架（vue-config-js）" class="headerlink" title="vue-lic3脚手架（vue.config.js）"></a>vue-lic3脚手架（vue.config.js）</h3><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>类型：String</p><p>默认：’/‘</p><p>部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如<a href="https://www.my-app.com/%E3%80%82%E5%A6%82%E6%9E%9C%E5%BA%94%E7%94%A8%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%90%E8%B7%AF%E5%BE%84%E4%B8%8A%EF%BC%8C%E4%BD%A0%E5%B0%B1%E9%9C%80%E8%A6%81%E7%94%A8%E8%BF%99%E4%B8%AA%E9%80%89%E9%A1%B9%E6%8C%87%E5%AE%9A%E8%BF%99%E4%B8%AA%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%9C%A8https://www.my-app.com/my-app/%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AEpublicPath%E4%B8%BA/my-app/">https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/</a></p><p>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘./‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p><h4 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h4><p>类型：boolean</p><p>moren：true</p><p>不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</p><blockquote><p>注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便</p></blockquote><h4 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h4><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是’’,</p><h4 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h4><p>指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是’index.html’</p><h4 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h4><p>是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;css: &#123;</span><br><span class="line"> &#x2F;&#x2F;是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，</span><br><span class="line"> extract: true,</span><br><span class="line"> sourceMap: false,&#x2F;&#x2F;效果同上</span><br><span class="line"> modules: false,&#x2F;&#x2F; 为所有的 CSS 及其预处理文件开启 CSS Modules。</span><br><span class="line"> &#x2F;&#x2F; 这个选项不会影响 &#96;*.vue&#96; 文件。</span><br><span class="line"> &#125;, 复制代码&#96;&#96;</span><br></pre></td></tr></table></figure><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><p>本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#96;devServer: &#123; </span><br><span class="line"> &#x2F;&#x2F;配置开发服务器</span><br><span class="line"> host: &quot;0.0.0.0&quot;,</span><br><span class="line"> &#x2F;&#x2F;是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果</span><br><span class="line"> hot: true,</span><br><span class="line"> &#x2F;&#x2F;服务启动端口</span><br><span class="line"> port: &quot;8080&quot;,</span><br><span class="line"> &#x2F;&#x2F;是否自动打开浏览器默认为false</span><br><span class="line"> open: false,</span><br><span class="line"> &#x2F;&#x2F;配置http代理</span><br><span class="line"> proxy: &#123; </span><br><span class="line"> &quot;&#x2F;api&quot;: &#123; &#x2F;&#x2F;如果ajax请求的地址是http:&#x2F;&#x2F;192.168.0.118:9999&#x2F;api1那么你就可以在jajx中使用&#x2F;api&#x2F;api1路径,其请求路径会解析</span><br><span class="line"> &#x2F;&#x2F; http:&#x2F;&#x2F;192.168.0.118:9999&#x2F;api1，当然你在浏览器上开到的还是http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;api1;</span><br><span class="line"> target: &quot;http:&#x2F;&#x2F;192.168.0.118:9999&quot;,</span><br><span class="line"> &#x2F;&#x2F;是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意</span><br><span class="line"> changeOrigin: true,</span><br><span class="line"> pathRewrite: &#123;</span><br><span class="line"> &#x2F;&#x2F;把多余的路径置为&#39;&#39;</span><br><span class="line"> &quot;api&quot;: &quot;&quot;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;&#x2F;api2&quot;: &#123;&#x2F;&#x2F;可以配置多个代理，匹配上那个就使用哪种解析方式</span><br><span class="line"> target: &quot;http:&#x2F;&#x2F;api2&quot;,</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="pluginOptions"><a href="#pluginOptions" class="headerlink" title="pluginOptions"></a>pluginOptions</h4><p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#123;</span><br><span class="line"> &#x2F;&#x2F;定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了</span><br><span class="line"> &#39;style-resources-loader&#39;: &#123;</span><br><span class="line"> preProcessor: &#39;less&#39;,</span><br><span class="line"> patterns: [</span><br><span class="line"> &#39;.&#x2F;src&#x2F;assets&#x2F;public.less&#39;</span><br><span class="line"> ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><h4 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h4><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#96;chainWebpack(config) &#123; </span><br><span class="line">&#x2F;&#x2F;添加一个路径别名 假设有在assets&#x2F;img&#x2F;menu&#x2F;目录下有十张图片，如果全路径require(&quot;&#x2F;assets&#x2F;img&#x2F;menu&#x2F;img1.png&quot;)</span><br><span class="line">&#x2F;&#x2F;去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了</span><br><span class="line"> config.resolve.alias</span><br><span class="line"> &#x2F;&#x2F;添加多个别名支持链式调用</span><br><span class="line"> .set(&quot;assets&quot;, path.join(__dirname, &quot;&#x2F;src&#x2F;assets&quot;))</span><br><span class="line"> .set(&quot;img&quot;, path.join(__dirname, &quot;&#x2F;src&#x2F;assets&#x2F;img&#x2F;menu&quot;))</span><br><span class="line"> &#x2F;&#x2F;引入图片时只需require(&quot;img&#x2F;img1.png&quot;);即可</span><br><span class="line">&#125; 复制代码&#96;</span><br></pre></td></tr></table></figure><p>参考：</p><p>1、Vue常见问题总结 <a href="https://blog.csdn.net/qq/_27674439/article/details/99449197">https://blog.csdn.net/qq\_27674439/article/details/99449197</a></p><p>2、vue常见面试题 <a href="https://zhuanlan.zhihu.com/p/92407628">https://zhuanlan.zhihu.com/p/92407628</a></p><p>3、vuex官网 <a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p><p>4、Vuex面试题汇总 <a href="https://juejin.im/post/5dba91e4518825647e4ef18b">https://juejin.im/post/5dba91e4518825647e4ef18b</a></p><p>5、Vue CLI官网 <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p><p>历史好文推荐：</p><p>1、<a href="https://juejin.im/post/5f0fe0ee5188252e53638634">【万字长文】史上最强css、html总结~看完涨薪不再是梦</a></p><p>2、<a href="https://juejin.im/post/5f14e786f265da22f511e98f">【万字长文】最全JavaScript基础总结~建议收藏</a></p><p>3、<a href="https://juejin.im/post/5f06870ae51d4534b3030043">Event Loop我知道，宏任务微任务是什么鬼？</a></p><p>4、<a href="https://juejin.im/post/5f0439caf265da22ed5114e3">锋利码农武器之vscode</a></p><p>5、<a href="https://juejin.im/post/5f02e9e6e51d4534bf67bac6">面试宝典带你走上人生巅峰</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/vue-ji-qiao/"/>
      <url>/2020/09/07/vue-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h4 id="1-内部监听生命周期函数"><a href="#1-内部监听生命周期函数" class="headerlink" title="1. 内部监听生命周期函数"></a>1. 内部监听生命周期函数</h4><p>今天产品经理又给我甩过来一个需求，需要开发一个图表，拿到需求，瞄了一眼，然后我就去<code>echarts</code>官网复制示例代码了，复制完改了改差不多了，改完代码长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;echarts&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.chart &#x3D; echarts.init(this.$el)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    </span><br><span class="line">    window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    $_handleResizeChart() &#123;</span><br><span class="line">      this.chart.resize()</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>功能写完开开心心的提测了，测试没啥问题，产品经理表示做的很棒。然而code review时候，技术大佬说了，这样有问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 大佬：这样写不是很好，应该将监听&#96;resize&#96;事件与销毁&#96;resize&#96;事件放到一起，现在两段代码分开而且相隔几百行代码，可读性比较差</span><br><span class="line"></span><br><span class="line"> 我：那我把两个生命周期钩子函数位置换一下，放到一起?</span><br><span class="line"></span><br><span class="line"> 大佬： &#96;hook&#96;听过没？</span><br><span class="line"></span><br><span class="line"> 我：&#96;Vue3.0&#96;才有啊，咋，咱要升级&#96;Vue&#96;?</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后技术大佬就不理我了,并向我扔过来一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.chart &#x3D; echarts.init(this.$el)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)</span><br><span class="line">    </span><br><span class="line">    this.$once(&#39;hook:beforeDestroy&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">      window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;&#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    $_handleResizeChart() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看完代码，恍然大悟，大佬不愧是大佬，原来<code>Vue</code>还可以这样监听生命周期函数。</p><p><em>在<code>Vue</code>组件中，可以用过<code>$on</code>,<code>$once</code>去监听所有的生命周期钩子函数，如监听组件的<code>updated</code>钩子函数可以写成 <code>this.$on(&#39;hook:updated&#39;, () =&gt; &#123;&#125;)</code></em></p><h4 id="2-外部监听生命周期函数"><a href="#2-外部监听生命周期函数" class="headerlink" title="2. 外部监听生命周期函数"></a>2. 外部监听生命周期函数</h4><p>今天同事在公司群里问，想在外部监听组件的生命周期函数，有没有办法啊？</p><p>为什么会有这样的需求呢，原来同事用了一个第三方组件，需要监听第三方组件数据的变化，但是组件又没有提供<code>change</code>事件，同事也没办法了，才想出来要去在外部监听组件的<code>updated</code>钩子函数。查看了一番资料，发现<code>Vue</code>支持在外部监听组件的生命周期钩子函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &lt;custom-select @hook:updated&#x3D;&quot;$_handleSelectUpdated&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import CustomSelect from &#39;..&#x2F;components&#x2F;custom-select&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    CustomSelect</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    $_handleSelectUpdated() &#123;</span><br><span class="line">      console.log(&#39;custom-select组件的updated钩子函数被触发&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><blockquote><p>❝</p><h3 id="小项目还用Vuex-用Vue-observable手写一个状态管理吧"><a href="#小项目还用Vuex-用Vue-observable手写一个状态管理吧" class="headerlink" title="小项目还用Vuex?用Vue.observable手写一个状态管理吧"></a>小项目还用<code>Vuex</code>?用<code>Vue.observable</code>手写一个状态管理吧</h3><p>❞</p></blockquote><p>在前端项目中，有许多数据需要在各个组件之间进行传递共享，这时候就需要有一个状态管理工具，一般情况下，我们都会使用<code>Vuex</code>，但对于小型项目来说，就像<code>Vuex</code>官网所说：“如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex”。这时候我们就可以使用<code>Vue2.6</code>提供的新API <code>Vue.observable</code>手动打造一个<code>Vuex</code></p><h4 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 <code>store</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const store &#x3D; Vue.observable(&#123;</span><br><span class="line">  userInfo: &#123;&#125;,</span><br><span class="line">  roleIds: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">  setUserInfo(userInfo) &#123;</span><br><span class="line">    store.userInfo &#x3D; userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  setRoleIds(roleIds) &#123;</span><br><span class="line">    store.roleIds &#x3D; roleIds</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="在组件中引用"><a href="#在组件中引用" class="headerlink" title="在组件中引用"></a>在组件中引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; userInfo.name &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; store, mutations &#125; from &#39;..&#x2F;store&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    userInfo() &#123;</span><br><span class="line">      return store.userInfo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    mutations.setUserInfo(&#123;</span><br><span class="line">      name: &#39;子君&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><blockquote><p>❝</p><h3 id="开发全局组件，你可能需要了解一下Vue-extend"><a href="#开发全局组件，你可能需要了解一下Vue-extend" class="headerlink" title="开发全局组件，你可能需要了解一下Vue.extend"></a>开发全局组件，你可能需要了解一下<code>Vue.extend</code></h3><p>❞</p></blockquote><p><code>Vue.extend</code>是一个全局Api,平时我们在开发业务的时候很少会用到它，但有时候我们希望可以开发一些全局组件比如<code>Loading</code>,<code>Notify</code>,<code>Message</code>等组件时，这时候就可以使用<code>Vue.extend</code>。</p><p>同学们在使用<code>element-ui</code>的<code>loading</code>时，在代码中可能会这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const loading &#x3D; this.$loading()</span><br><span class="line"></span><br><span class="line">loading.close()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样写可能没什么特别的，但是如果你这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const loading &#x3D; this.$loading()</span><br><span class="line">const loading1 &#x3D; this.$loading()</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  loading.close()</span><br><span class="line">&#125;, 1000 * 3)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这时候你会发现，我调用了两次loading,但是只出现了一个，而且我只关闭了<code>loading</code>，但是<code>loading1</code>也被关闭了。这是怎么实现的呢？我们现在就是用<code>Vue.extend</code> + 单例模式去实现一个<code>loading</code></p><h4 id="开发loading组件"><a href="#开发loading组件" class="headerlink" title="开发loading组件"></a>开发<code>loading</code>组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition name&#x3D;&quot;custom-loading-fade&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div v-show&#x3D;&quot;visible&quot; class&#x3D;&quot;custom-loading-mask&quot;&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;div class&#x3D;&quot;custom-loading-spinner&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;custom-spinner-icon&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;p class&#x3D;&quot;custom-loading-text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;transition&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">  </span><br><span class="line">    visible: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    text: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>开发出来<code>loading</code>组件之后，如果需要直接使用，就要这样去用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;component-code&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;custom-loading :visible&#x3D;&quot;visible&quot; text&#x3D;&quot;加载中&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visible: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但这样使用并不能满足我们的需求</p><ol><li><p>可以通过js直接调用方法来显示关闭</p></li><li><p><code>loading</code>可以将整个页面全部遮罩起来</p></li></ol><h4 id="通过Vue-extend将组件转换为全局组件"><a href="#通过Vue-extend将组件转换为全局组件" class="headerlink" title="通过Vue.extend将组件转换为全局组件"></a>通过<code>Vue.extend</code>将组件转换为全局组件</h4><h5 id="1-改造loading组件，将组件的props改为data"><a href="#1-改造loading组件，将组件的props改为data" class="headerlink" title="1. 改造loading组件，将组件的props改为data"></a>1. 改造<code>loading</code>组件，将组件的<code>props</code>改为<code>data</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#39;&#39;,</span><br><span class="line">      visible: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="2-通过Vue-extend改造组件"><a href="#2-通过Vue-extend改造组件" class="headerlink" title="2. 通过Vue.extend改造组件"></a>2. 通过<code>Vue.extend</code>改造组件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import LoadingComponent from &#39;.&#x2F;loading.vue&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const LoadingConstructor &#x3D; Vue.extend(LoadingComponent)</span><br><span class="line"></span><br><span class="line">let loading &#x3D; undefined</span><br><span class="line"></span><br><span class="line">LoadingConstructor.prototype.close &#x3D; function() &#123;</span><br><span class="line">  </span><br><span class="line">  if (loading) &#123;</span><br><span class="line">    loading &#x3D; undefined</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  this.visible &#x3D; false</span><br><span class="line">  </span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    if (this.$el &amp;&amp; this.$el.parentNode) &#123;</span><br><span class="line">      this.$el.parentNode.removeChild(this.$el)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.$destroy()</span><br><span class="line">  &#125;, 300)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Loading &#x3D; (options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  if (loading) &#123;</span><br><span class="line">    return loading</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const parent &#x3D; document.body</span><br><span class="line">  </span><br><span class="line">  const opts &#x3D; &#123;</span><br><span class="line">    text: &#39;&#39;,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const instance &#x3D; new LoadingConstructor(&#123;</span><br><span class="line">    el: document.createElement(&#39;div&#39;),</span><br><span class="line">    data: opts</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  parent.appendChild(instance.$el)</span><br><span class="line">  </span><br><span class="line">  Vue.nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    instance.visible &#x3D; true</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  loading &#x3D; instance</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Loading</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="3-在页面使用loading"><a href="#3-在页面使用loading" class="headerlink" title="3. 在页面使用loading"></a>3. 在页面使用loading</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Loading from &#39;.&#x2F;loading&#x2F;index.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    const loading &#x3D; Loading(&#123; text: &#39;正在加载。。。&#39; &#125;)</span><br><span class="line">    </span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      loading.close()</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过上面的改造，loading已经可以在全局使用了，如果需要像<code>element-ui</code>一样挂载到<code>Vue.prototype</code>上面，通过<code>this.$loading</code>调用，还需要改造一下</p><h4 id="将组件挂载到Vue-prototype上面"><a href="#将组件挂载到Vue-prototype上面" class="headerlink" title="将组件挂载到Vue.prototype上面"></a>将组件挂载到<code>Vue.prototype</code>上面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$loading &#x3D; Loading</span><br><span class="line">&#x2F;&#x2F; 在export之前将Loading方法进行绑定</span><br><span class="line">export default Loading</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在组件内使用</span><br><span class="line">this.$loading()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><blockquote><p>❝</p><h3 id="自定义指令，从底层解决问题"><a href="#自定义指令，从底层解决问题" class="headerlink" title="自定义指令，从底层解决问题"></a>自定义指令，从底层解决问题</h3><p>❞</p></blockquote><p>什么是指令？指令就是你女朋友指着你说，“那边搓衣板，跪下，这是命令！”。开玩笑啦，程序员哪里会有女朋友。</p><p>通过上一节我们开发了一个<code>loading</code>组件，开发完之后，其他开发在使用的时候又提出来了两个需求</p><ol><li><p>可以将<code>loading</code>挂载到某一个元素上面，现在只能是全屏使用</p></li><li><p>可以使用指令在指定的元素上面挂载<code>loading</code></p></li></ol><p>有需求，咱就做，没话说</p><h4 id="开发v-loading指令"><a href="#开发v-loading指令" class="headerlink" title="开发v-loading指令"></a>开发<code>v-loading</code>指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import LoadingComponent from &#39;.&#x2F;loading&#39;</span><br><span class="line"></span><br><span class="line">const LoadingContructor &#x3D; Vue.extend(LoadingComponent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.directive(&#39;loading&#39;, &#123;</span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure><h4 id="在元素上面使用指令"><a href="#在元素上面使用指令" class="headerlink" title="在元素上面使用指令"></a>在元素上面使用指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-loading&#x3D;&quot;visible&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visible: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.visible &#x3D; true</span><br><span class="line">    fetch().then(() &#x3D;&gt; &#123;</span><br><span class="line">      this.visible &#x3D; false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="项目中哪些场景可以自定义指令"><a href="#项目中哪些场景可以自定义指令" class="headerlink" title="项目中哪些场景可以自定义指令"></a>项目中哪些场景可以自定义指令</h4><ol><li><p>为组件添加<code>loading</code>效果</p></li><li><p>按钮级别权限控制 <code>v-permission</code></p></li><li><p>代码埋点,根据操作类型定义指令</p></li><li><p>input输入框自动获取焦点</p></li><li><p>其他等等。。。</p></li></ol><hr><blockquote><p>❝</p><h3 id="深度watch与watch立即触发回调-我可以监听到你的一举一动"><a href="#深度watch与watch立即触发回调-我可以监听到你的一举一动" class="headerlink" title="深度watch与watch立即触发回调,我可以监听到你的一举一动"></a>深度<code>watch</code>与<code>watch</code>立即触发回调,我可以监听到你的一举一动</h3><p>❞</p></blockquote><p>在开发Vue项目时，我们会经常性的使用到<code>watch</code>去监听数据的变化，然后在变化之后做一系列操作。</p><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>比如一个列表页，我们希望用户在搜索框输入搜索关键字的时候，可以自动触发搜索,此时除了监听搜索框的<code>change</code>事件之外，我们也可以通过<code>watch</code>监听搜索关键字的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;搜索&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;input v-model&#x3D;&quot;searchValue&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      searchValue: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    </span><br><span class="line">    searchValue(newValue, oldValue) &#123;</span><br><span class="line">      </span><br><span class="line">      if (newValue !&#x3D;&#x3D; oldValue) &#123;</span><br><span class="line">        this.$_loadData()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    $_loadData() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="立即触发"><a href="#立即触发" class="headerlink" title="立即触发"></a>立即触发</h4><p>通过上面的代码，现在已经可以在值发生变化的时候触发加载数据了，但是如果要在页面初始化时候加载数据，我们还需要在<code>created</code>或者<code>mounted</code>生命周期钩子里面再次调用<code>$_loadData</code>方法。不过，现在可以不用这样写了，通过配置<code>watch</code>的立即触发属性，就可以满足需求了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    </span><br><span class="line">    searchValue: &#123;</span><br><span class="line">    </span><br><span class="line">      handler(newValue, oldValue) &#123;</span><br><span class="line">        if (newValue !&#x3D;&#x3D; oldValue) &#123;</span><br><span class="line">          this.$_loadData()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="深度监听（我可以看到你内心的一举一动）"><a href="#深度监听（我可以看到你内心的一举一动）" class="headerlink" title="深度监听（我可以看到你内心的一举一动）"></a>深度监听（我可以看到你内心的一举一动）</h4><p>一个表单页面，需求希望用户在修改表单的任意一项之后，表单页面就需要变更为被修改状态。如果按照上例中<code>watch</code>的写法，那么我们就需要去监听表单每一个属性，太麻烦了，这时候就需要用到<code>watch</code>的深度监听<code>deep</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      formData: &#123;</span><br><span class="line">        name: &#39;&#39;,</span><br><span class="line">        sex: &#39;&#39;,</span><br><span class="line">        age: 0,</span><br><span class="line">        deptId: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    </span><br><span class="line">    formData: &#123;</span><br><span class="line">      </span><br><span class="line">      handler(newValue, oldValue) &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      deep: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="随时监听，随时取消，了解一下-watch"><a href="#随时监听，随时取消，了解一下-watch" class="headerlink" title="随时监听，随时取消，了解一下$watch"></a>随时监听，随时取消，了解一下<code>$watch</code></h4><p>有这样一个需求，有一个表单，在编辑的时候需要监听表单的变化，如果发生变化则保存按钮启用，否则保存按钮禁用。这时候对于新增表单来说，可以直接通过<code>watch</code>去监听表单数据(假设是<code>formData</code>),如上例所述，但对于编辑表单来说，表单需要回填数据，这时候会修改<code>formData</code>的值，会触发<code>watch</code>,无法准确的判断是否启用保存按钮。现在你就需要了解一下<code>$watch</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      formData: &#123;</span><br><span class="line">        name: &#39;&#39;,</span><br><span class="line">        age: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.$_loadData()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    </span><br><span class="line">    $_loadData() &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        this.formData &#x3D; &#123;</span><br><span class="line">          name: &#39;子君&#39;,</span><br><span class="line">          age: 18</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        const unwatch &#x3D; this.$watch(</span><br><span class="line">          &#39;formData&#39;,</span><br><span class="line">          () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;数据发生了变化&#39;)</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            deep: true</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          this.formData.name &#x3D; &#39;张三&#39;</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>根据上例可以看到，我们可以在需要的时候通过<code>this.$watch</code>来监听数据变化。那么如何取消监听呢，上例中<code>this.$watch</code>返回了一个值<code>unwatch</code>,是一个函数，在需要取消的时候，执行 <code>unwatch()</code>即可取消</p><p>本文使用 <a href="https://mdnice.com/">mdnice</a> 排版</p><hr><blockquote><p>❝</p><h3 id="函数式组件，函数是组件？"><a href="#函数式组件，函数是组件？" class="headerlink" title="函数式组件，函数是组件？"></a>函数式组件，函数是组件？</h3><p>❞</p></blockquote><p>什么是函数式组件？函数式组件就是函数是组件，感觉在玩文字游戏。使用过<code>React</code>的同学，应该不会对函数式组件感到陌生。函数式组件，我们可以理解为没有内部状态，没有生命周期钩子函数，没有<code>this</code>(不需要实例化的组件)。</p><p>在日常写bug的过程中，经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是只需要将外部传入的数据进行展现，不需要有内部状态，不需要在生命周期钩子函数里面做处理，这时候你就可以考虑使用函数式组件。</p><h4 id="先来一个函数式组件的代码"><a href="#先来一个函数式组件的代码" class="headerlink" title="先来一个函数式组件的代码"></a>先来一个函数式组件的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  </span><br><span class="line">  functional: true,</span><br><span class="line">  </span><br><span class="line">  props: &#123;</span><br><span class="line">    avatar: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure><p>在上例中，我们定义了一个头像组件，如果外部传入头像，则显示传入的头像，否则显示默认头像。上面的代码中大家看到有一个render函数，这个是<code>Vue</code>使用<code>JSX</code>的写法，关于<code>JSX</code>,小编将在后续文章中会出详细的使用教程。</p><h4 id="为什么使用函数式组件"><a href="#为什么使用函数式组件" class="headerlink" title="为什么使用函数式组件"></a>为什么使用函数式组件</h4><ol><li><p>最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件</p></li><li><p>函数式组件结构比较简单，代码结构更清晰</p></li></ol><h5 id="函数式组件与普通组件的区别"><a href="#函数式组件与普通组件的区别" class="headerlink" title="函数式组件与普通组件的区别"></a>函数式组件与普通组件的区别</h5><ol><li><p>函数式组件需要在声明组件是指定functional</p></li><li><p>函数式组件不需要实例化，所以没有<code>this</code>,<code>this</code>通过<code>render</code>函数的第二个参数来代替</p></li><li><p>函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等</p></li><li><p>函数式组件不能通过$emit对外暴露事件，调用事件只能通过<code>context.listeners.click</code>的方式调用外部传入的事件</p></li><li><p>因为函数式组件是没有实例化的，所以在外部通过<code>ref</code>去引用组件时，实际引用的是<code>HTMLElement</code></p></li><li><p>函数式组件的<code>props</code>可以不用显示声明，所以没有在<code>props</code>里面声明的属性都会被自动隐式解析为<code>prop</code>,而普通组件所有未声明的属性都被解析到<code>$attrs</code>里面，并自动挂载到组件根元素上面(可以通过<code>inheritAttrs</code>属性禁止)</p></li></ol><h4 id="我不想用JSX，能用函数式组件吗？"><a href="#我不想用JSX，能用函数式组件吗？" class="headerlink" title="我不想用JSX，能用函数式组件吗？"></a>我不想用<code>JSX</code>，能用函数式组件吗？</h4><p>在<code>Vue2.5</code>之前，使用函数式组件只能通过<code>JSX</code>的方式，在之后，可以通过模板语法来生命函数式组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;img :src&#x3D;&quot;props.avatar ? props.avatar : &#39;default-avatar.png&#39;&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/typescript-ru-men/"/>
      <url>/2020/09/07/typescript-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="typescript入门"><a href="#typescript入门" class="headerlink" title="typescript入门"></a>typescript入门</h2><p><strong>其实<code>Vue</code>官方从<code>2.6.X</code>版本开始就部分使用<code>Ts</code>重写了。</strong></p><p>我个人对更严格类型限制没有积极的看法，毕竟各类转类型的骚写法写习惯了。</p><p>然鹅最近的一个项目中，是<code>TypeScript</code>+ <code>Vue</code>，毛计喇，学之……真香！</p><p><strong>注意此篇标题的“前”，本文旨在讲<code>Ts</code>混入框架的使用，不讲<code>Class API</code></strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/13/16b5094ed2a96828?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="1-使用官方脚手架构建"><a href="#1-使用官方脚手架构建" class="headerlink" title="1. 使用官方脚手架构建"></a>1. 使用官方脚手架构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br><span class="line"></span><br><span class="line">yarn global add @vue&#x2F;cli</span><br></pre></td></tr></table></figure><p>新的<code>Vue CLI</code>工具允许开发者 使用 <code>TypeScript</code> 集成环境 创建新项目。</p><p>只需运行<code>vue create my-app</code>。</p><p>然后，命令行会要求选择预设。使用箭头键选择<code>Manually select features</code>。</p><p>接下来，只需确保选择了<code>TypeScript</code>和<code>Babel</code>选项，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a57d82715e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>完成此操作后，它会询问你是否要使用<code>class-style component syntax</code>。</p><p>然后配置其余设置，使其看起来如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a57d83e1974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>Vue CLI工具现在将安装所有依赖项并设置项目。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a57dd7f8c66?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>接下来就跑项目喇。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a57daeaf341?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>总之，先跑起来再说。</p><h2 id="2-项目目录解析"><a href="#2-项目目录解析" class="headerlink" title="2. 项目目录解析"></a>2. 项目目录解析</h2><p>通过<code>tree</code>指令查看目录结构后可发现其结构和正常构建的大有不同。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a57e05c4d0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这里主要关注<code>shims-tsx.d.ts</code>和 <code>shims-vue.d.ts</code>两个文件</p><p>两句话概括：</p><ul><li><code>shims-tsx.d.ts</code>，允许你以<code>.tsx</code>结尾的文件，在<code>Vue</code>项目中编写<code>jsx</code>代码</li><li><code>shims-vue.d.ts</code> 主要用于 <code>TypeScript</code> 识别<code>.vue</code> 文件，<code>Ts</code>默认并不支持导入 <code>vue</code> 文件，这个文件告诉<code>ts</code> 导入<code>.vue</code> 文件都按<code>VueConstructor&lt;Vue&gt;</code>处理。</li></ul><p>此时我们打开亲切的<code>src/components/HelloWorld.vue</code>，将会发现写法已大有不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;!-- 省略 --&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Prop, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">  @Prop() private msg!: string;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>至此，准备开启新的篇章 <code>TypeScript</code>极速入门 和 <code>vue-property-decorator</code></p><h2 id="3-TypeScript极速入门"><a href="#3-TypeScript极速入门" class="headerlink" title="3. TypeScript极速入门"></a>3. <code>TypeScript</code>极速入门</h2><h3 id="3-1-基本类型和扩展类型"><a href="#3-1-基本类型和扩展类型" class="headerlink" title="3.1 基本类型和扩展类型"></a>3.1 基本类型和扩展类型</h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a57de204bb4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><code>Typescript</code>与<code>Javascript</code>共享相同的基本类型，但有一些额外的类型。</p><ul><li>元组 <code>Tuple</code></li><li>枚举 <code>enum</code></li><li><code>Any</code> 与<code>Void</code></li></ul><h4 id="1-基本类型合集"><a href="#1-基本类型合集" class="headerlink" title="1. 基本类型合集"></a>1. 基本类型合集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数字，二、八、十六进制都支持</span><br><span class="line">let decLiteral: number &#x3D; 6;</span><br><span class="line">let hexLiteral: number &#x3D; 0xf00d;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串，单双引都行</span><br><span class="line">let name: string &#x3D; &quot;bob&quot;;</span><br><span class="line">let sentence: string &#x3D; &#96;Hello, my name is $&#123; name &#125;.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组，第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</span><br><span class="line">let list: number[] &#x3D; [1, 2, 3];</span><br><span class="line">let list: Array&lt;number&gt; &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let u: undefined &#x3D; undefined;</span><br><span class="line">let n: null &#x3D; null;</span><br></pre></td></tr></table></figure><h4 id="2-特殊类型"><a href="#2-特殊类型" class="headerlink" title="2. 特殊类型"></a>2. 特殊类型</h4><h5 id="1-元组-Tuple"><a href="#1-元组-Tuple" class="headerlink" title="1. 元组 Tuple"></a>1. <strong>元组 <code>Tuple</code></strong><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a58028534c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></h5><p>想象 元组 作为有组织的数组，你需要以正确的顺序预定义数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const messyArray &#x3D; [&#39; something&#39;, 2, true, undefined, null];</span><br><span class="line">const tuple: [number, string, string] &#x3D; [24, &quot;Indrek&quot; , &quot;Lasn&quot;]</span><br></pre></td></tr></table></figure><p>如果不遵循 为元组 预设排序的索引规则，那么<code>Typescript</code>会警告。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a580a458319?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p> （<code>tuple</code>第一项应为<code>number</code>类型）</p><h5 id="2-枚举-enum"><a href="#2-枚举-enum" class="headerlink" title="2. 枚举 enum"></a>2. 枚举 <code>enum</code></h5><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a580c96180f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认情况从0开始为元素编号，也可手动为1开始</span><br><span class="line">enum Color &#123;Red &#x3D; 1, Green &#x3D; 2, Blue &#x3D; 4&#125;</span><br><span class="line">let c: Color &#x3D; Color.Green;</span><br><span class="line"></span><br><span class="line">let colorName: string &#x3D; Color[2];</span><br><span class="line">console.log(colorName);  &#x2F;&#x2F; 输出&#39;Green&#39;因为上面代码里它的值是2</span><br></pre></td></tr></table></figure><p>另一个很好的例子是使用枚举来存储应用程序状态。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a580eb8d6f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h5 id="3-Void"><a href="#3-Void" class="headerlink" title="3. Void"></a>3. <code>Void</code></h5><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a5811b7c692?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在<code>Typescript</code>中，<strong>你必须在函数中定义返回类型</strong>。像这样：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a58137c6084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>若没有返回值，则会报错：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a58322260c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>我们可以将其返回值定义为<code>void</code>:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a582b658d41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>此时将无法 <code>return</code></p><h5 id="4-Any"><a href="#4-Any" class="headerlink" title="4. Any"></a>4. <code>Any</code></h5><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a58357d0129?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>Emmm…就是什么类型都行，当你无法确认在处理什么类型时可以用这个。</p><p>但要慎重使用，用多了就失去使用Ts的意义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let person: any &#x3D; &quot;前端劝退师&quot;</span><br><span class="line">person &#x3D; 25</span><br><span class="line">person &#x3D; true</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>主要应用场景有：</p><ol><li>接入第三方库</li><li>Ts菜逼前期都用</li></ol><h5 id="5-Never"><a href="#5-Never" class="headerlink" title="5. Never"></a>5. <code>Never</code></h5><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a5836a7344f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>用很粗浅的话来描述就是：”<code>Never</code>是你永远得不到的爸爸。”</p><p>具体的行为是：</p><ul><li><code>throw new Error(message)</code></li><li><code>return error(&quot;Something failed&quot;)</code></li><li><code>while (true) &#123;&#125; // 存在无法达到的终点</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a5839fb5caa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="3-类型断言"><a href="#3-类型断言" class="headerlink" title="3. 类型断言"></a>3. 类型断言</h4><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a584a48d1d6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>简略的定义是：可以用来手动指定一个值的类型。</p><p>有两种写法，尖括号和<code>as</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any &#x3D; &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number &#x3D; (&lt;string&gt;someValue).length;</span><br><span class="line">let strLength: number &#x3D; (someValue as string).length;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用例子有：</p><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.</span><br><span class="line">&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你访问长度将会报错，而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，此时需要断言才不会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="3-2-泛型：Generics"><a href="#3-2-泛型：Generics" class="headerlink" title="3.2 泛型：Generics"></a>3.2 泛型：<code>Generics</code></h3><p>软件工程的一个主要部分就是构建组件，构建的组件不仅需要具有明确的定义和统一的接口，同时也需要组件可复用。支持现有的数据类型和将来添加的数据类型的组件为大型软件系统的开发过程提供很好的灵活性。</p><p>在<code>C#</code>和<code>Java</code>中，可以使用”泛型”来创建可复用的组件，并且组件可支持多种数据类型。这样便可以让用户根据自己的数据类型来使用组件。</p><h4 id="1-泛型方法"><a href="#1-泛型方法" class="headerlink" title="1. 泛型方法"></a>1. 泛型方法</h4><p>在TypeScript里，<strong>声明泛型方法</strong>有以下两种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function gen_func1&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">let gen_func2: &lt;T&gt;(arg: T) &#x3D;&gt; T &#x3D; function (arg) &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用方式</strong>也有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen_func1&lt;string&gt;(&#39;Hello world&#39;);</span><br><span class="line">gen_func2(&#39;Hello world&#39;); </span><br><span class="line">&#x2F;&#x2F; 第二种调用方式可省略类型参数，因为编译器会根据传入参数来自动识别对应的类型。</span><br></pre></td></tr></table></figure><h4 id="2-泛型与Any"><a href="#2-泛型与Any" class="headerlink" title="2. 泛型与Any"></a>2. 泛型与<code>Any</code></h4><p><code>Ts</code> 的特殊类型 <code>Any</code> 在具体使用时，可以代替任意类型，咋一看两者好像没啥区别，其实不然：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一：带有any参数的方法</span><br><span class="line">function any_func(arg: any): any &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法二：Array泛型方法</span><br><span class="line">function array_func&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法一，打印了<code>arg</code>参数的<code>length</code>属性。因为<code>any</code>可以代替任意类型，所以该方法在传入参数不是数组或者带有<code>length</code>属性对象时，会抛出异常。</li><li>方法二，定义了参数类型是<code>Array</code>的泛型类型，肯定会有<code>length</code>属性，所以不会抛出异常。</li></ul><h4 id="3-泛型类型"><a href="#3-泛型类型" class="headerlink" title="3. 泛型类型"></a>3. 泛型类型</h4><p>泛型接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Generics_interface&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function func_demo&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let func1: Generics_interface&lt;number&gt; &#x3D; func_demo;</span><br><span class="line">func1(123);     &#x2F;&#x2F; 正确类型的实际参数</span><br><span class="line">func1(&#39;123&#39;);   &#x2F;&#x2F; 错误类型的实际参数</span><br></pre></td></tr></table></figure><h3 id="3-3-自定义类型：Interface-vs-Type-alias"><a href="#3-3-自定义类型：Interface-vs-Type-alias" class="headerlink" title="3.3 自定义类型：Interface vs Type alias"></a>3.3 自定义类型：<code>Interface</code> vs <code>Type alias</code></h3><p><code>Interface</code>，国内翻译成接口。</p><p><code>Type alias</code>，类型别名。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/13/16b512f2dc49f9e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>以下内容来自：</p><blockquote><p><a href="https://juejin.im/post/5c2723635188252d1d34dc7d#heading-11">Typescript 中的 interface 和 type 到底有什么区别</a></p></blockquote><h4 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h4><p><strong>都可以用来描述一个对象或函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#x3D; &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">interface SetUser &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br><span class="line">type SetUser &#x3D; (name: string, age: number): void;</span><br></pre></td></tr></table></figure><p><strong>都允许拓展（extends）：</strong></p><p><code>interface</code> 和 <code>type</code> 都可以拓展，并且两者并不是相互独立的，也就是说<code>interface</code>可以 <code>extends type</code>, <code>type</code> 也可以 <code>extends interface</code> 。 <strong>虽然效果差不多，但是两者语法不同</strong>。</p><p><strong>interface extends interface</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>type extends type</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name &#x3D; &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User &#x3D; Name &amp; &#123; age: number  &#125;;</span><br></pre></td></tr></table></figure><p><strong>interface extends type</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Name &#x3D; &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>type extends interface</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User &#x3D; Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-不同点"><a href="#2-不同点" class="headerlink" title="2. 不同点"></a>2. 不同点</h4><p><strong><code>type</code> 可以而 <code>interface</code> 不行</strong></p><ul><li><code>type</code> 可以声明基本类型别名，联合类型，元组等类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本类型别名</span><br><span class="line">type Name &#x3D; string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pet &#x3D; Dog | Cat</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 具体定义数组每个位置的类型</span><br><span class="line">type PetList &#x3D; [Dog, Pet] </span><br></pre></td></tr></table></figure><ul><li><code>type</code> 语句中还可以使用 <code>typeof</code>获取实例的 类型进行赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeof</span><br><span class="line">let div &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">type B &#x3D; typeof div </span><br></pre></td></tr></table></figure><ul><li>其他骚操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type StringOrNumber &#x3D; string | number;  </span><br><span class="line">type Text &#x3D; string | &#123; text: string &#125;;  </span><br><span class="line">type NameLookup &#x3D; Dictionary&lt;string, Person&gt;;  </span><br><span class="line">type Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;  </span><br><span class="line">type Pair&lt;T&gt; &#x3D; [T, T];  </span><br><span class="line">type Coordinates &#x3D; Pair&lt;number&gt;;  </span><br><span class="line">type Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;; </span><br></pre></td></tr></table></figure><p><strong><code>interface</code>可以而 <code>type</code>不行</strong></p><p><code>interface</code> 能够声明合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p><code>interface</code> 有可选属性和只读属性</p><ul><li><p>可选属性</p><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 例如给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。如下所示</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  gender?: number;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>只读属性</p><p>顾名思义就是这个属性是不可写的，对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性，如下所示：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">    readonly loginName: string;</span><br><span class="line">    password: string;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面的例子说明，当完成User对象的初始化后loginName就不可以修改了。</p><h3 id="3-4-实现与继承：implementsvsextends"><a href="#3-4-实现与继承：implementsvsextends" class="headerlink" title="3.4 实现与继承：implementsvsextends"></a>3.4 实现与继承：<code>implements</code>vs<code>extends</code></h3><p><code>extends</code>很明显就是ES6里面的类继承，那么<code>implement</code>又是做什么的呢？它和<code>extends</code>有什么不同？</p><p><code>implement</code>，实现。与C#或Java里接口的基本作用一样，<code>TypeScript</code>也能够用它来明确的强制一个类去符合某种契约</p><p><strong>implement基本用法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface IDeveloper &#123;</span><br><span class="line">   name: string;</span><br><span class="line">   age?: number;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; OK</span><br><span class="line">class dev implements IDeveloper &#123;</span><br><span class="line">    name &#x3D; &#39;Alex&#39;;</span><br><span class="line">    age &#x3D; 20;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; OK</span><br><span class="line">class dev2 implements IDeveloper &#123;</span><br><span class="line">    name &#x3D; &#39;Alex&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Error</span><br><span class="line">class dev3 implements IDeveloper &#123;</span><br><span class="line">    name &#x3D; &#39;Alex&#39;;</span><br><span class="line">    age &#x3D; &#39;9&#39;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>而<code>extends</code>是继承父类，两者其实可以混着用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class A extends B implements C,D,E </span><br></pre></td></tr></table></figure><p>搭配 <code>interface</code>和<code>type</code>的用法有：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b47a58564149b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="3-5-声明文件与命名空间：declare-和-namespace"><a href="#3-5-声明文件与命名空间：declare-和-namespace" class="headerlink" title="3.5 声明文件与命名空间：declare 和 namespace"></a>3.5 声明文件与命名空间：<code>declare</code> 和 <code>namespace</code></h3><p>前面我们讲到Vue项目中的<code>shims-tsx.d.ts</code>和<code>shims-vue.d.ts</code>，其初始内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; shims-tsx.d.ts</span><br><span class="line">import Vue, &#123; VNode &#125; from &#39;vue&#39;;</span><br><span class="line"></span><br><span class="line">declare global &#123;</span><br><span class="line">  namespace JSX &#123;</span><br><span class="line">    &#x2F;&#x2F; tslint:disable no-empty-interface</span><br><span class="line">    interface Element extends VNode &#123;&#125;</span><br><span class="line">    &#x2F;&#x2F; tslint:disable no-empty-interface</span><br><span class="line">    interface ElementClass extends Vue &#123;&#125;</span><br><span class="line">    interface IntrinsicElements &#123;</span><br><span class="line">      [elem: string]: any;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; shims-vue.d.ts</span><br><span class="line">declare module &#39;*.vue&#39; &#123;</span><br><span class="line">  import Vue from &#39;vue&#39;;</span><br><span class="line">  export default Vue;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>declare</code>：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><p>这里列举出几个常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">declare var 声明全局变量</span><br><span class="line">declare function 声明全局方法</span><br><span class="line">declare class 声明全局类</span><br><span class="line">declare enum 声明全局枚举类型</span><br><span class="line">declare global 扩展全局变量</span><br><span class="line">declare module 扩展模块</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><code>namespace</code>：“内部模块”现在称做“命名空间”</p><p><code>module X &#123;</code> 相当于现在推荐的写法 <code>namespace X &#123;</code>)</p><h2 id="跟其他-JS-库协同"><a href="#跟其他-JS-库协同" class="headerlink" title="跟其他 JS 库协同"></a>跟其他 JS 库协同</h2><p>类似模块，同样也可以通过为其他 JS 库使用了命名空间的库创建 <code>.d.ts</code> 文件的声明文件，如为 <code>D3</code> JS 库，可以创建这样的声明文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare namespace D3&#123;</span><br><span class="line">    export interface Selectors &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">declare var d3: D3.Base; </span><br></pre></td></tr></table></figure><p>所以上述两个文件：</p><ul><li><code>shims-tsx.d.ts</code>， 在全局变量 <code>global</code>中批量命名了数个内部模块。</li><li><code>shims-vue.d.ts</code>，意思是告诉 <code>TypeScript</code> <code>*.vue</code> 后缀的文件可以交给 <code>vue</code> 模块来处理。</li></ul><h3 id="3-6-访问修饰符：private、public、protected"><a href="#3-6-访问修饰符：private、public、protected" class="headerlink" title="3.6 访问修饰符：private、public、protected"></a>3.6 访问修饰符：<code>private</code>、<code>public</code>、<code>protected</code></h3><p>其实很好理解：</p><ol><li><p>默认为<code>public</code></p></li><li><p>当成员被标记为<code>private</code>时，它就不能在声明它的类的外部访问，比如：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123;</span><br><span class="line">        this.name &#x3D; theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a &#x3D; new Animal(&#39;Cat&#39;).name; &#x2F;&#x2F;错误，‘name’是私有的 </span><br></pre></td></tr></table></figure><ol start="3"><li><code>protected</code>和<code>private</code>类似，但是，<code>protected</code>成员在派生类中可以访问</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(theName: string) &#123;</span><br><span class="line">        this.name &#x3D; theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rhino extends Animal &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(&#39;Rhino&#39;);</span><br><span class="line">   &#125;         </span><br><span class="line">   getName() &#123;</span><br><span class="line">       console.log(this.name) &#x2F;&#x2F;此处的name就是Animal类中的name</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3-7-可选参数-和非空断言操作符（-）"><a href="#3-7-可选参数-和非空断言操作符（-）" class="headerlink" title="3.7 可选参数 ( ?: )和非空断言操作符（!.）"></a>3.7 可选参数 ( ?: )和非空断言操作符（!.）</h3><p><strong>可选参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    return firstName + &#39; &#39; + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误演示</span><br><span class="line">buildName(&quot;firstName&quot;, &quot;lastName&quot;, &quot;lastName&quot;)</span><br><span class="line">&#x2F;&#x2F; 正确演示</span><br><span class="line">buildName(&quot;firstName&quot;)</span><br><span class="line">&#x2F;&#x2F; 正确演示</span><br><span class="line">buildName(&quot;firstName&quot;, &quot;lastName&quot;) </span><br></pre></td></tr></table></figure><p><strong>非空断言操作符：</strong></p><p>能确定变量值一定不为空时使用。</p><p>与可选参数 不同的是，非空断言操作符不会防止出现 null 或 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s &#x3D; e!.name;  &#x2F;&#x2F; 断言e是非空并访问name属性 </span><br></pre></td></tr></table></figure><h2 id="4-Vue组件的Ts写法"><a href="#4-Vue组件的Ts写法" class="headerlink" title="4. Vue组件的Ts写法"></a>4. <code>Vue</code>组件的<code>Ts</code>写法</h2><p>从 vue2.5 之后，vue 对 ts 有更好的支持。根据<a href="https://vuejs.org/v2/guide/typescript.html">官方文档</a>，vue 结合 typescript ，有两种书写方式：</p><p>**Vue.extend **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">const Component &#x3D; Vue.extend(&#123;</span><br><span class="line">&#x2F;&#x2F; type inference enabled</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p><strong>vue-class-component</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class Test extends Vue &#123;</span><br><span class="line">  @Prop(&#123; type: Object &#125;)</span><br><span class="line">  private test: &#123; value: string &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理想情况下，<code>Vue.extend</code> 的书写方式，是学习成本最低的。在现有写法的基础上，几乎 0 成本的迁移。</p><p>但是<code>Vue.extend</code>模式，需要与<code>mixins</code> 结合使用。在 mixin 中定义的方法，不会被 typescript 识别到</p><p>，这就意味着会出现<strong>丢失代码提示、类型检查、编译报错等问题。</strong></p><p>菜鸟才做选择，大佬都挑最好的。直接讲第二种吧：</p><h3 id="4-1-vue-class-component"><a href="#4-1-vue-class-component" class="headerlink" title="4.1 vue-class-component"></a>4.1 <code>vue-class-component</code></h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b53b466001ed96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>我们回到<code>src/components/HelloWorld.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;!-- 省略 --&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Prop, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">  @Prop() private msg!: string;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;&#x2F;style&gt; </span><br></pre></td></tr></table></figure><p>有写过<code>python</code>的同学应该会发现似曾相识：</p><ul><li><code>vue-property-decorator</code>这个官方支持的库里，提供了函数 **装饰器（修饰符）**语法</li></ul><h4 id="1-函数修饰符"><a href="#1-函数修饰符" class="headerlink" title="1. 函数修饰符 @"></a>1. 函数修饰符 <code>@</code></h4><p>“@”，与其说是修饰函数倒不如说是引用、调用它修饰的函数。</p><p>或者用句大白话描述：<code>@</code>: “下面的被我包围了。”</p><p>举个栗子，下面的一段代码，里面两个函数，没有被调用，也会有输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(f)&#123;</span><br><span class="line">    console.log(&quot;before ...&quot;);</span><br><span class="line">    f()</span><br><span class="line">console.log(&quot;after ...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@test</span><br><span class="line">func()&#123;</span><br><span class="line">console.log(&quot;func was called&quot;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>直接运行，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before ...</span><br><span class="line">func was called</span><br><span class="line">after ... </span><br></pre></td></tr></table></figure><p>上面代码可以看出来:</p><ul><li>只定义了两个函数：<code>test</code>和<code>func</code>，没有调用它们。</li><li>如果没有<a href="mailto:%22@test">“@test</a>”，运行应该是没有任何输出的。</li></ul><p>但是，解释器读到函数修饰符“@”的时候，后面步骤会是这样：</p><ol><li><p>去调用<code>test</code>函数，<code>test</code>函数的入口参数就是那个叫“<code>func</code>”的函数；</p></li><li><p><code>test</code>函数被执行，入口参数的（也就是<code>func</code>函数）会被调用（执行）；</p></li></ol><p>换言之，修饰符带的那个函数的入口参数，就是下面的那个整个的函数。有点儿类似<code>JavaScrip</code>t里面的 <code>function a (function () &#123; ... &#125;);</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/13/16b512f30ff5e238?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="2-vue-property-decorator和vuex-class提供的装饰器"><a href="#2-vue-property-decorator和vuex-class提供的装饰器" class="headerlink" title="2. vue-property-decorator和vuex-class提供的装饰器"></a>2. <code>vue-property-decorator</code>和<code>vuex-class</code>提供的装饰器</h4><p><code>vue-property-decorator</code>的装饰器：</p><ul><li><a href="https://github.com/kaorun343/vue-property-decorator#Prop"><code>@Prop</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#PropSync"><code>@PropSync</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#Provide"><code>@Provide</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#Model"><code>@Model</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#Watch"><code>@Watch</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#Provide"><code>@Inject</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#Provide"><code>@Provide</code></a></li><li><a href="https://github.com/kaorun343/vue-property-decorator#Emit"><code>@Emit</code></a></li><li><code>@Component</code> (<strong>provided by</strong> <a href="https://github.com/vuejs/vue-class-component">vue-class-component</a>)</li><li><code>Mixins</code> (the helper function named <code>mixins</code> <strong>provided by</strong> <a href="https://github.com/vuejs/vue-class-component">vue-class-component</a>)</li></ul><p><code>vuex-class</code>的装饰器：</p><ul><li>@State</li><li>@Getter</li><li>@Action</li><li>@Mutation</li></ul><p>我们拿原始Vue组件模版来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123;componentA,componentB&#125; from &#39;@&#x2F;components&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123; componentA, componentB&#125;,</span><br><span class="line">props: &#123;</span><br><span class="line">    propA: &#123; type: Number &#125;,</span><br><span class="line">    propB: &#123; default: &#39;default value&#39; &#125;,</span><br><span class="line">    propC: &#123; type: [String, Boolean] &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 组件数据</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 计算属性</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reversedMessage () &#123;</span><br><span class="line">      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Vuex数据</span><br><span class="line">    step() &#123;</span><br><span class="line">    return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMessage () &#123;</span><br><span class="line">      this.message &#x3D; &quot;Good bye&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    let name &#x3D; this.$store.getters[&#39;person&#x2F;name&#39;]</span><br><span class="line">    return name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 生命周期</span><br><span class="line">  created () &#123; &#125;,</span><br><span class="line">  mounted () &#123; &#125;,</span><br><span class="line">  updated () &#123; &#125;,</span><br><span class="line">  destroyed () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>以上模版替换成修饰符写法则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import &#123; State, Getter &#125; from &#39;vuex-class&#39;;</span><br><span class="line">import &#123; count, name &#125; from &#39;@&#x2F;person&#39;</span><br><span class="line">import &#123; componentA, componentB &#125; from &#39;@&#x2F;components&#39;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    components:&#123; componentA, componentB&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class HelloWorld extends Vue&#123;</span><br><span class="line">@Prop(Number) readonly propA!: number | undefined</span><br><span class="line">    @Prop(&#123; default: &#39;default value&#39; &#125;) readonly propB!: string</span><br><span class="line">    @Prop([String, Boolean]) readonly propC!: string | boolean | undefined</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 原data</span><br><span class="line">  message &#x3D; &#39;Hello&#39;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 计算属性</span><br><span class="line">private get reversedMessage (): string[] &#123;</span><br><span class="line">  return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Vuex 数据</span><br><span class="line">  @State((state: IRootState) &#x3D;&gt; state . booking. currentStep) step!: number</span><br><span class="line">@Getter( &#39;person&#x2F;name&#39;) name!: name</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; method</span><br><span class="line">  public changeMessage (): void &#123;</span><br><span class="line">    this.message &#x3D; &#39;Good bye&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  public getName(): string &#123;</span><br><span class="line">    let storeName &#x3D; name</span><br><span class="line">    return storeName</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 生命周期</span><br><span class="line">  private created ()：void &#123; &#125;,</span><br><span class="line">  private mounted ()：void &#123; &#125;,</span><br><span class="line">  private updated ()：void &#123; &#125;,</span><br><span class="line">  private destroyed ()：void &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>正如你所看到的，我们在生命周期 列表那都添加<code>private XXXX</code>方法，因为这不应该公开给其他组件。</p><p>而不对<code>method</code>做私有约束的原因是，可能会用到<code>@Emit</code>来向父组件传递信息。</p><h3 id="4-2-添加全局工具"><a href="#4-2-添加全局工具" class="headerlink" title="4.2 添加全局工具"></a>4.2 添加全局工具</h3><p>引入全局模块，需要改<code>main.ts</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: (h) &#x3D;&gt; h(App),</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><code>npm i VueI18n</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">&#x2F;&#x2F; 新模块</span><br><span class="line">import i18n from &#39;.&#x2F;i18n&#39;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    router, </span><br><span class="line">    store, </span><br><span class="line">    i18n, &#x2F;&#x2F; 新模块</span><br><span class="line">    render: (h) &#x3D;&gt; h(App),</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>但仅仅这样，还不够。你需要动<code>src/vue-shim.d.ts</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明全局方法</span><br><span class="line">declare module &#39;vue&#x2F;types&#x2F;vue&#39; &#123;</span><br><span class="line">  interface Vue &#123;</span><br><span class="line">        readonly $i18n: VueI18Next;</span><br><span class="line">        $t: TranslationFunction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>之后使用<code>this.$i18n()</code>的话就不会报错了。</p><h3 id="4-3-Axios-使用与封装"><a href="#4-3-Axios-使用与封装" class="headerlink" title="4.3 Axios 使用与封装"></a>4.3 Axios 使用与封装</h3><p><code>Axios</code>的封装千人千面</p><p>如果只是想简单在Ts里体验使用<code>Axios</code>，可以安装<code>vue-axios</code> <strong>简单使用<code>Axios</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i axios vue-axios</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><code>main.ts</code>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import VueAxios from &#39;vue-axios&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueAxios, axios)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>然后在组件内使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.axios.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.axios.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.$http.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="1-新建文件request-ts"><a href="#1-新建文件request-ts" class="headerlink" title="1. 新建文件request.ts"></a>1. 新建文件<code>request.ts</code></h4><p>文件目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-api</span><br><span class="line">    - main.ts   &#x2F;&#x2F; 实际调用</span><br><span class="line">-utils</span><br><span class="line">    - request.ts  &#x2F;&#x2F; 接口封装</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="2-request-ts文件解析"><a href="#2-request-ts文件解析" class="headerlink" title="2. request.ts文件解析"></a>2. <code>request.ts</code>文件解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import * as axios from &#39;axios&#39;;</span><br><span class="line">import store from &#39;@&#x2F;store&#39;;</span><br><span class="line">&#x2F;&#x2F; 这里可根据具体使用的UI组件库进行替换</span><br><span class="line">import &#123; Toast &#125; from &#39;vant&#39;;</span><br><span class="line">import &#123; AxiosResponse, AxiosRequestConfig &#125; from &#39;axios&#39;;</span><br><span class="line"> </span><br><span class="line"> &#x2F;* baseURL 按实际项目来定义 *&#x2F;</span><br><span class="line">const baseURL &#x3D; process.env.VUE_APP_URL;</span><br><span class="line"></span><br><span class="line"> &#x2F;* 创建axios实例 *&#x2F;</span><br><span class="line">const service &#x3D; axios.default.create(&#123;</span><br><span class="line">    baseURL,</span><br><span class="line">    timeout: 0, &#x2F;&#x2F; 请求超时时间</span><br><span class="line">    maxContentLength: 4000,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">service.interceptors.request.use((config: AxiosRequestConfig) &#x3D;&gt; &#123;</span><br><span class="line">    return config;</span><br><span class="line">&#125;, (error: any) &#x3D;&gt; &#123;</span><br><span class="line">    Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">    (response: AxiosResponse) &#x3D;&gt; &#123;</span><br><span class="line">        if (response.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">            Toast.fail(&#39;请求错误！&#39;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return response.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    (error: any) &#x3D;&gt; &#123;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">export default service;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>为了方便，我们还需要定义一套固定的 axios 返回的格式，新建<code>ajax.ts</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export interface AjaxResponse &#123;</span><br><span class="line">    code: number;</span><br><span class="line">    data: any;</span><br><span class="line">    message: string;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="3-main-ts接口调用："><a href="#3-main-ts接口调用：" class="headerlink" title="3. main.ts接口调用："></a>3. <code>main.ts</code>接口调用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; api&#x2F;main.ts</span><br><span class="line">import request from &#39;..&#x2F;utils&#x2F;request&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get</span><br><span class="line">export function getSomeThings(params:any) &#123;</span><br><span class="line">    return request(&#123;</span><br><span class="line">        url: &#39;&#x2F;api&#x2F;getSomethings&#39;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post</span><br><span class="line">export function postSomeThings(params:any) &#123;</span><br><span class="line">    return request(&#123;</span><br><span class="line">        url: &#39;&#x2F;api&#x2F;postSomethings&#39;,</span><br><span class="line">        methods: &#39;post&#39;,</span><br><span class="line">        data: params</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="5-编写一个组件"><a href="#5-编写一个组件" class="headerlink" title="5. 编写一个组件"></a>5. 编写一个组件</h2><p>为了减少时间，我们来替换掉<code>src/components/HelloWorld.vue</code>，做一个博客帖子组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;blogpost&quot;&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;meta&quot;&gt;Written by &#123;&#123; post.author &#125;&#125; on &#123;&#123; date &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Prop, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在这里对数据进行类型约束</span><br><span class="line">export interface Post &#123;</span><br><span class="line">title: string;</span><br><span class="line">body: string;</span><br><span class="line">author: string;</span><br><span class="line">datePosted: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">@Prop() private post!: Post;</span><br><span class="line"></span><br><span class="line">get date() &#123;</span><br><span class="line">return &#96;$&#123;this.post.datePosted.getDate()&#125;&#x2F;$&#123;this.post.datePosted.getMonth()&#125;&#x2F;$&#123;this.post.datePosted.getFullYear()&#125;&#96;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h2 &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">p.meta &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>然后在<code>Home.vue</code>中使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">   &lt;HelloWorld v-for&#x3D;&quot;blogPost in blogPosts&quot; :post&#x3D;&quot;blogPost&quot; :key&#x3D;&quot;blogPost.title&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import HelloWorld, &#123; Post &#125; from &#39;@&#x2F;components&#x2F;HelloWorld.vue&#39;; &#x2F;&#x2F; @ is an alias to &#x2F;src</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class Home extends Vue &#123;</span><br><span class="line">    private blogPosts: Post[] &#x3D; [</span><br><span class="line">        &#123;</span><br><span class="line">          title: &#39;My first blogpost ever!&#39;,</span><br><span class="line">          body: &#39;Lorem ipsum dolor sit amet.&#39;,</span><br><span class="line">          author: &#39;Elke&#39;,</span><br><span class="line">          datePosted: new Date(2019, 1, 18),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &#39;Look I am blogging!&#39;,</span><br><span class="line">          body: &#39;Hurray for me, this is my second post!&#39;,</span><br><span class="line">          author: &#39;Elke&#39;,</span><br><span class="line">          datePosted: new Date(2019, 1, 19),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &#39;Another one?!&#39;,</span><br><span class="line">          body: &#39;Another one!&#39;,</span><br><span class="line">          author: &#39;Elke&#39;,</span><br><span class="line">          datePosted: new Date(2019, 1, 20),</span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这时候运行项目：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b53ada6dbb6000?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这就是简单的父子组件</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/13/16b512f306db5c07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6. 参考文章"></a>6. 参考文章</h2><p><a href="https://medium.com/cleversonder/typescript-javascript-with-superpowers-part-ii-69a6bd2c6842">TypeScript — JavaScript with superpowers — Part II</a></p><p><a href="https://ordina-jworks.github.io/vue/2019/03/04/vue-with-typescript.html#6-your-first-deployment">VUE WITH TYPESCRIPT</a></p><p><a href="https://juejin.im/post/5b54886ce51d45198f5c75d7#heading-6">TypeScript + 大型项目实战</a></p><p><a href="https://blog.csdn.net/972301/article/details/59537712">Python修饰符 （一）—— 函数修饰符 “@”</a></p><p><a href="https://juejin.im/post/5c2723635188252d1d34dc7d#heading-11">Typescript 中的 interface 和 type到底有什么区别</a></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b53e37a96b8d86?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>而关于<code>Class API</code>撤销，其实还是挺舒服的。 用<code>class</code> 来编写 <code>Vue</code>组件确实太奇怪了。 (所以我这篇<code>Ts</code>入门压根没写<code>Class API</code>)</p><h2 id="https-user-gold-cdn-xitu-io-2019-6-14-16b53e5d5fd4daa2-imageView2-0-w-1280-h-960-format-webp-ignore-error-1"><a href="#https-user-gold-cdn-xitu-io-2019-6-14-16b53e5d5fd4daa2-imageView2-0-w-1280-h-960-format-webp-ignore-error-1" class="headerlink" title="![](https://user-gold-cdn.xitu.io/2019/6/14/16b53e5d5fd4daa2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></a>![](<a href="https://user-gold-cdn.xitu.io/2019/6/14/16b53e5d5fd4daa2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">https://user-gold-cdn.xitu.io/2019/6/14/16b53e5d5fd4daa2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/javascripts-yun-xing-ji-zhi/"/>
      <url>/2020/09/07/javascripts-yun-xing-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScripts运行机制"><a href="#JavaScripts运行机制" class="headerlink" title="JavaScripts运行机制"></a>JavaScripts运行机制</h2><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>区分进程和线程</p></li><li><p>浏览器是多进程的</p><ul><li><p>浏览器都包含哪些进程？</p></li><li><p>浏览器多进程的优势</p></li><li><p>重点是浏览器内核（渲染进程）</p></li><li><p>Browser进程和浏览器内核（Renderer进程）的通信过程</p></li></ul></li><li><p>梳理浏览器内核中线程之间的关系</p><ul><li><p>GUI渲染线程与JS引擎线程互斥</p></li><li><p>JS阻塞页面加载</p></li><li><p>WebWorker，JS的多线程？</p></li><li><p>WebWorker与SharedWorker</p></li></ul></li><li><p>简单梳理下浏览器渲染流程</p><ul><li><p>load事件与DOMContentLoaded事件的先后</p></li><li><p>css加载是否会阻塞dom树渲染？</p></li><li><p>普通图层和复合图层</p></li></ul></li><li><p>从Event Loop谈JS的运行机制</p><ul><li><p>事件循环机制进一步补充</p></li><li><p>单独说说定时器</p></li><li><p>setTimeout而不是setInterval</p></li></ul></li><li><p>事件循环进阶：macrotask与microtask</p></li><li><p>写在最后的话</p></li></ul><h2 id="区分进程和线程"><a href="#区分进程和线程" class="headerlink" title="区分进程和线程"></a>区分进程和线程</h2><p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 进程是一个工厂，工厂有它的独立资源</span><br><span class="line"></span><br><span class="line">- 工厂之间相互独立</span><br><span class="line"></span><br><span class="line">- 线程是工厂中的工人，多个工人协作完成任务</span><br><span class="line"></span><br><span class="line">- 工厂内有一个或多个工人</span><br><span class="line"></span><br><span class="line">- 工人之间共享空间</span><br></pre></td></tr></table></figure><p>再完善完善概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</span><br><span class="line"></span><br><span class="line">- 工厂之间的相互独立 -&gt; 进程之间相互独立</span><br><span class="line"></span><br><span class="line">- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</span><br><span class="line"></span><br><span class="line">- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</span><br><span class="line"></span><br><span class="line">- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</span><br></pre></td></tr></table></figure><p>然后再巩固下：</p><p>如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d7c9377?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>所以，应该更容易理解了：<strong>进程是cpu资源分配的最小单位（系统会给它分配内存）</strong></p><p>最后，再用较为官方的术语描述一遍：</p><ul><li><p>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</p></li><li><p>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p></li></ul><p><strong>tips</strong></p><ul><li><p>不同进程之间也可以通信，不过代价较大</p></li><li><p>现在，一般通用的叫法：<strong>单线程与多线程</strong>，都是指<strong>在一个进程内</strong>的单和多。（所以核心还是得属于一个进程才行）</p></li></ul><h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h2><p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p><ul><li><p>浏览器是多进程的</p></li><li><p>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</p></li><li><p>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</p></li></ul><p>关于以上几点的验证，<strong>请再第一张图</strong>：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d813f16?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>图中打开了<code>Chrome</code>浏览器的多个标签页，然后可以在<code>Chrome的任务管理器</code>中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上</p><p>**注意：**在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）</p><h3 id="浏览器都包含哪些进程？"><a href="#浏览器都包含哪些进程？" class="headerlink" title="浏览器都包含哪些进程？"></a>浏览器都包含哪些进程？</h3><p>知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）</p><ol><li><p>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p><ul><li><p>负责浏览器界面显示，与用户交互。如前进，后退等</p></li><li><p>负责各个页面的管理，创建和销毁其他进程</p></li><li><p>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</p></li><li><p>网络资源的管理，下载等</p></li></ul></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p></li><li><p>GPU进程：最多一个，用于3D绘制等</p></li><li><p>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为</p><ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ol><p>强化记忆：<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p><p>当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b32460672?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>另外，可以通过Chrome的<code>更多工具 -&gt; 任务管理器</code>自行验证</p><h3 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h3><p>相比于单进程浏览器，多进程有如下优点：</p><ul><li><p>避免单个page crash影响整个浏览器</p></li><li><p>避免第三方插件crash影响整个浏览器</p></li><li><p>多进程充分利用多核优势</p></li><li><p>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p></li></ul><p>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</strong></p><p>当然，内存等资源消耗也会更大，有点空间换时间的意思。</p><h3 id="重点是浏览器内核（渲染进程）"><a href="#重点是浏览器内核（渲染进程）" class="headerlink" title="重点是浏览器内核（渲染进程）"></a>重点是浏览器内核（渲染进程）</h3><p>重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是<strong>渲染进程</strong></p><p>可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程</p><p><strong>请牢记，浏览器的渲染进程是多线程的</strong>（这点如果不理解，<strong>请回头看进程和线程的区分</strong>）</p><p>终于到了线程这个概念了😭，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p><ol><li><p>GUI渲染线程</p><ul><li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p></li><li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p></li><li><p>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中<strong>等到JS引擎空闲时</strong>立即被执行。</p></li></ul></li><li><p>JS引擎线程</p><ul><li><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</p></li><li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li></ul></li><li><p>事件触发线程</p><ul><li><p>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p></li><li><p>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</p></li><li><p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p></li><li><p>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p></li></ul></li><li><p>定时触发器线程</p><ul><li><p>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</p></li><li><p>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</p></li><li><p>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p></li><li><p>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p></li></ul></li><li><p>异步http请求线程</p><ul><li><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</p></li><li><p>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p></li></ul></li></ol><p>看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于<code>事件触发线程</code>的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d39a5b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。</p><h3 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h3><p>看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p><p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）</strong>， 然后在这前提下，看下整个的过程：(简化了很多)</p><ul><li><p>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</p></li><li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p><ul><li><p>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</p></li><li><p>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</p></li><li><p>最后Render进程将结果传递给Browser进程</p></li></ul></li><li><p>Browser进程接收到结果并将结果绘制出来</p></li></ul><p>这里绘一张简单的图：（很简化）</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b2e66d44f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。</p><p>这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。</p><p>如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错</p><h2 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h2><p>到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念</p><h3 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h3><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><h3 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h3><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h3><p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p><p>所以，后来HTML5中支持了<code>Web Worker</code>。</p><p>MDN的官方解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面</span><br><span class="line"></span><br><span class="line">一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 </span><br><span class="line"></span><br><span class="line">这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window</span><br><span class="line"></span><br><span class="line">因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误</span><br></pre></td></tr></table></figure><p>这样理解下：</p><ul><li><p>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</p></li><li><p>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p></li></ul><p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><p>其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。</p><h3 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h3><p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p><ul><li><p>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</p><ul><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li></ul></li><li><p>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p><ul><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li></ul></li></ul><p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</p><h2 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h2><p>本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）</p><p>为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 浏览器输入url，浏览器主进程接管，开一个下载线程，</span><br><span class="line">然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，</span><br><span class="line">随后将内容通过RendererHost接口转交给Renderer进程</span><br><span class="line"></span><br><span class="line">- 浏览器渲染流程开始</span><br></pre></td></tr></table></figure><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><ol><li><p>解析html建立dom树</p></li><li><p>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</p></li><li><p>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</p></li><li><p>绘制render树（paint），绘制页面像素信息</p></li><li><p>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</p></li></ol><p>所有详细步骤都已经略去，渲染完毕后就是<code>load</code>事件了，之后就是自己的JS逻辑处理了</p><p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p><p>这里重绘参考来源中的一张图：（参考来源第一篇）</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611cb18d3a3938b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h3><p>上面提到，渲染完毕后会触发<code>load</code>事件，那么你能分清楚<code>load</code>事件与<code>DOMContentLoaded</code>事件的先后么？</p><p>很简单，知道它们的定义就可以了：</p><ul><li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)</p></li><li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）</p></li></ul><p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p><h3 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h3><p>这里说的是头部引入css的情况</p><p>首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong></p><p>然后再说下几个现象：</p><ul><li><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</p></li><li><p>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p></li></ul><p>这可能也是浏览器的一种优化机制。</p><p>因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h3 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h3><p>渲染步骤中就提到了<code>composite</code>概念。</p><p>可以简单的这样理解，浏览器渲染的图层一般包含两大类：<code>普通图层</code>以及<code>复合图层</code></p><p>首先，普通文档流内可以理解为一个复合图层（这里称为<code>默认复合层</code>，里面不管添加多少元素，其实都是在同一个复合图层中）</p><p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于<code>默认复合层</code>。</p><p>然后，可以通过<code>硬件加速</code>的方式，声明一个<code>新的复合图层</code>，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响<code>默认复合层</code>里的回流重绘）</p><p>可以简单理解下：<strong>GPU中，各个复合图层是单独绘制的，所以互不影响</strong>，这也是为什么某些场景硬件加速效果一级棒</p><p>可以<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息</p><p>如下图。可以验证上述的说法</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b2d83a384?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><strong>如何变成复合图层（硬件加速）</strong></p><p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p><ul><li><p>最常用的方式：<code>translate3d</code>、<code>translateZ</code></p></li><li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p></li><li><p><code>will-chang</code>属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p></li><li><p><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</p></li><li><p>其它，譬如以前的flash插件</p></li></ul><p><strong>absolute和硬件加速的区别</strong></p><p>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。 所以，就算absolute中信息改变时不会改变普通文档流中render树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><p><strong>复合图层的作用？</strong></p><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡</p><p><strong>硬件加速时请使用index</strong></p><p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染</p><p>具体的原理时这样的： <strong>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能</strong></p><p>简单点理解，其实可以认为是一个隐式合成的概念：<strong>如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层</strong>，这点需要特别注意</p><p>另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：</p><p><a href="http://web.jobbole.com/83575/">web.jobbole.com/83575/</a></p><h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。</p><p>注意，这里不谈<code>可执行上下文</code>，<code>VO</code>，<code>scop chain</code>等概念（这些完全可以整理成另一篇文章了），这里主要是结合<code>Event Loop</code>来谈JS代码是如何执行的。</p><p>读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p><ul><li><p>JS引擎线程</p></li><li><p>事件触发线程</p></li><li><p>定时触发器线程</p></li></ul><p>然后再理解一个概念：</p><ul><li><p>JS分为同步任务和异步任务</p></li><li><p>同步任务都在主线程上执行，形成一个<code>执行栈</code></p></li><li><p>主线程之外，<strong>事件触发线程</strong>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</p></li><li><p>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到可执行栈中，开始执行。</p></li></ul><p>看图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b898ed9ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。</p><h3 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" class="headerlink" title="事件循环机制进一步补充"></a>事件循环机制进一步补充</h3><p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href="http://vimeo.com/96425312">Help, I’m stuck in an event-loop</a>》）</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938ba2b4b9f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>上图大致描述就是：</p><ul><li><p>主线程运行时会产生执行栈， 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</p></li><li><p>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</p></li><li><p>如此循环</p></li><li><p>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</p></li></ul><h3 id="单独说说定时器"><a href="#单独说说定时器" class="headerlink" title="单独说说定时器"></a>单独说说定时器</h3><p>上述事件循环机制的核心是：JS引擎线程和事件触发线程</p><p>但事件上，里面还有一些隐藏细节，譬如调用<code>setTimeout</code>后，是如何等待特定时间后才添加到事件队列中的？</p><p>是JS引擎检测的么？当然不是了。它是由<strong>定时器线程</strong>控制（因为JS引擎自己都忙不过来，根本无暇分身）</p><p>为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p><p>什么时候会用到定时器线程？<strong>当使用<code>setTimeout</code>或<code>setInterval</code>时</strong>，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p><p>譬如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#39;hello!&#39;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>这段代码的作用是当<code>1000</code>毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#39;hello!&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">console.log(&#39;begin&#39;);</span><br></pre></td></tr></table></figure><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行</p><p>注意：</p><ul><li><p>执行结果是：先<code>begin</code>后<code>hello!</code></p></li><li><p>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定)</p></li><li><p>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行<code>begin</code>（因为只有可执行栈内空了后才会主动读取事件队列）</p></li></ul><h3 id="setTimeout而不是setInterval"><a href="#setTimeout而不是setInterval" class="headerlink" title="setTimeout而不是setInterval"></a>setTimeout而不是setInterval</h3><p>用setTimeout模拟定期计时和直接用setInterval是有区别的。</p><p>因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）</p><p>而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p><p>而且setInterval有一些比较致命的问题就是：</p><ul><li><p>累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）</p></li><li><p><del>譬如像iOS的webview,或者Safari等浏览器中都有一个特点，<strong>在滚动的时候是不执行JS的</strong>，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误</del>（这一块后续有补充，setInterval自带的优化，不会重复添加回调）</p></li><li><p>而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时</p></li></ul><p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：<strong>用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame</strong></p><p><strong>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。</strong></p><h2 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" class="headerlink" title="事件循环进阶：macrotask与microtask"></a>事件循环进阶：macrotask与microtask</h2><p>这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下）， 强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">jakearchibald.com/2015/tasks-…</a></p><p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;script end&#39;);</span><br></pre></td></tr></table></figure><p>嗯哼，它的正确执行顺序是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p>为什么呢？因为Promise里有了一个一个新的概念：<code>microtask</code></p><p>或者，进一步，JS中分为两种任务类型：**<code>macrotask</code>和<code>microtask</code>**，在ECMAScript中，microtask称为<code>jobs</code>，macrotask可称为<code>task</code></p><p>它们的定义？区别？简单点可以按如下理解：</p><ul><li><p>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p><ul><li><p>每一个task会从头到尾将这个任务执行完毕，不会执行其它</p></li><li><p>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （<code>task-&gt;渲染-&gt;task-&gt;...</code>）</p></li></ul></li><li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p><ul><li><p>也就是说，在当前task任务后，下一个task之前，在渲染之前</p></li><li><p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</p></li><li><p>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</p></li></ul></li></ul><p>分别很么样的场景会形成macrotask和microtask呢？</p><ul><li><p>macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</p></li><li><p>microtask：Promise，process.nextTick等</p></li></ul><p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。</p><p>参考：<a href="https://segmentfault.com/q/1010000011914016">segmentfault.com/q/101000001…</a></p><p>再根据线程来理解下：</p><ul><li><p>macrotask中的事件都是放在一个事件队列中的，而这个队列由<strong>事件触发线程</strong>维护</p></li><li><p>microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由<strong>JS引擎线程维护</strong> （这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</p></li></ul><p>所以，总结下运行机制：</p><ul><li><p>执行一个宏任务（栈中没有就从事件队列中获取）</p></li><li><p>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</p></li><li><p>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</p></li><li><p>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</p></li><li><p>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</p></li></ul><p>如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/21/1611938b96e93485?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</p><ul><li><p>官方版本中，是标准的microtask形式</p></li><li><p>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式</p></li><li><p>请特别注意这两点区别</p></li></ul><p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了）， 但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p><p><strong>20180126补充：使用MutationObserver实现microtask</strong></p><p>MutationObserver可以用来实现microtask （它属于microtask，优先级小于Promise， 一般是Promise不支持时才会这样做）</p><p>它是HTML5中的新特性，作用是：监听一个DOM变动， 当DOM对象树发生任何变动时，Mutation Observer会得到通知</p><p>像以前的Vue源码中就是利用它来模拟nextTick的， 具体原理是，创建一个TextNode并监听内容变化， 然后要nextTick的时候去改一下这个节点的文本内容， 如下：（Vue的源码，未修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; 1</span><br><span class="line">var observer &#x3D; new MutationObserver(nextTickHandler)</span><br><span class="line">var textNode &#x3D; document.createTextNode(String(counter))</span><br><span class="line"></span><br><span class="line">observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true</span><br><span class="line">&#125;)</span><br><span class="line">timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    counter &#x3D; (counter + 1) % 2</span><br><span class="line">    textNode.data &#x3D; String(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95">对应Vue源码链接</a></p><p>不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因）， 取而代之的是使用MessageChannel （当然，默认情况仍然是Promise，不支持才兼容的）。</p><p>MessageChannel属于宏任务，优先级是：<code>MessageChannel-&gt;setTimeout</code>， 所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p><p>这里不展开，可以看下<a href="https://juejin.im/post/5a1af88f5188254a701ec230">juejin.im/post/5a1af8…</a></p><ul><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/07/flex-bu-ju/"/>
      <url>/2020/09/07/flex-bu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在项目中，遇到布局问题，有时候，需要堆叠很多的样式，去排版，一定程度上增加了代码量，那么有没有更加方便的布局方式呢？👇</p><p>48张图带你从0到1掌握flex布局方式。</p><p><code>flex布局</code>在某种程度上，简便我们布局的一个难题，接下来的篇幅将介绍它的使用👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad4dc9d88834a8e831c03de2b9e624c~tplv-k3u1fbpfcp-zoom-1.image"></p><p>需要本文的Xmind导图的话，移步公众号–<strong>前端UpUp</strong>,回复<code>flex</code>关键字即可。</p><h2 id="flex基本概念"><a href="#flex基本概念" class="headerlink" title="flex基本概念"></a>flex基本概念</h2><p>要想熟练掌握flex布局的话，你需要理解两个概念：<code>轴</code>和<code>容器</code>👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30ae5302cb1c4488af8e011bcdb9a64b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>从上面图来看，我们将flex布局分为两部分讲，<code>轴</code>和<code>容器</code>。</p><p><strong>轴</strong></p><ul><li>主轴（mian axis）</li><li>交叉轴（cross axis）</li></ul><p><strong>容器</strong></p><ul><li>父容器（container)</li><li>子容器（item）</li></ul><p>打个预防针，<code>flex布局</code>涉及到12个CSS属性，父容器,子容器各6个。</p><p>接下来先梳理常见的属性，不常见的放在进阶部分来梳理。</p><h3 id="轴"><a href="#轴" class="headerlink" title="轴"></a>轴</h3><p>我们知道，<code>轴</code>包括<code>主轴</code>和<code>交叉轴</code>,那么它们的方向是如何决定呢？我们直接从一张图看懂它👇</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8563c81d90394784b32c023b725f454c~tplv-k3u1fbpfcp-zoom-1.image"></p><p>默认情况下，<strong>主轴</strong>的方向是从左向右的，<strong>交叉轴</strong>垂直于主轴，逆时针方向90度，那么接下来我们看<strong>flex-direction</strong>是如何决定主轴的。讲这个之前，我们需要明白👇</p><ul><li><p>交叉轴是由主轴决定的，主轴又是由flex-direction决定的。</p></li><li><p>flex-direction属性设置在父容器上，这样子才可以生效。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47eeb569967e4c2eb64c2b539f8b35ee~tplv-k3u1fbpfcp-zoom-1.image"></p><p>首先布局如下👇</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex1&quot;</span>&gt;</span>子盒子#flex1: 1 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex2&quot;</span>&gt;</span>子盒子#flex2: 1 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们看看他们的效果吧👇</p><hr><h4 id="flex-direction-row"><a href="#flex-direction-row" class="headerlink" title="flex-direction: row"></a>flex-direction: row</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">flex-direction: row</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c8d0fdfb00435c8c25c0eb0c4b8d8e~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong></p><ul><li>flex容器的主轴被定义为与文本方向相同。 主轴起点和主轴终点与内容方向相同。</li><li>简单理解就是<strong>主轴沿着水平方向向右</strong></li></ul><hr><h4 id="flex-direction-row-reverse"><a href="#flex-direction-row-reverse" class="headerlink" title="flex-direction: row-reverse"></a>flex-direction: row-reverse</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">flex-direction: row-reverse</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f20b904b939419aafd9060969262108~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我们可以看到这两个盒子的位置发生了变化，这个就是主轴起点和主轴终点位置<strong>置换</strong>的原因。</p><p><strong>结论</strong></p><ul><li>表现和row相同，但是置换了主轴起点和主轴终点。</li><li>简单理解就是<strong>主轴沿着水平方向向左</strong>，与文本方向相反。</li></ul><hr><h4 id="flex-direction-column"><a href="#flex-direction-column" class="headerlink" title="flex-direction: column"></a>flex-direction: column</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">flex-direction: column</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/263bf603893b49da987fbfdda7e61e5d~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看到，子盒子的布局发生了变化，形成了在Y轴上的布局方式,并且书写方式跟布局一样。</p><p><strong>结论</strong></p><ul><li>flex容器的主轴和块轴相同。主轴起点与主轴终点和书写模式的前后点相同</li><li>简单的理解，就是主轴变成Y轴方向，方向从上到下布局。</li></ul><hr><h4 id="flex-direction-column-reverse"><a href="#flex-direction-column-reverse" class="headerlink" title="flex-direction: column-reverse"></a>flex-direction: column-reverse</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">flex-direction: column-reverse</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76432fefc1b449fb81dc3f257788b1cd~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看到，子盒子的布局跟column差不多，唯一不同的是，方向上发生了变化。</p><p><strong>结论</strong></p><ul><li>表现和<code>column</code>相同，但是置换了主轴起点和主轴终点</li><li>简单的理解，就是主轴变成Y轴方向，方向从下到上，与书写的方向相反。</li></ul><hr><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>这里就分为<strong>父容器</strong>和<strong>子容器</strong>，我们先来看看父容器👇</p><h4 id="父容器"><a href="#父容器" class="headerlink" title="父容器"></a>父容器</h4><ul><li>justify-content: <strong>设置子元素在主轴方向上的对齐方式</strong></li><li>align-items： <strong>设置子元素在交叉轴方向上的对齐方式</strong></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1bdef0b27d4256a91c3e72bbc83fce~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>这个属性设置在父容器上，<strong>决定子元素在主轴方向上的对齐方式</strong>，我们看看它们具体表现吧👇</p><hr><h4 id="justify-content-flex-start"><a href="#justify-content-flex-start" class="headerlink" title="justify-content: flex-start"></a>justify-content: flex-start</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">justify-content: flex-start</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ec9455f3adf4e82b9db1afb15d23a02~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素沿着主轴方向开始对齐。</p><hr><h4 id="justify-content-flex-end"><a href="#justify-content-flex-end" class="headerlink" title="justify-content: flex-end"></a>justify-content: flex-end</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">justify-content: flex-end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9a466a6f5a64a77ac6478ae6c804d73~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素沿着主轴方向终点对齐。</p><hr><h4 id="justify-content-center"><a href="#justify-content-center" class="headerlink" title="justify-content: center"></a>justify-content: center</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">justify-content: center</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b82988c18c49ebbf5cbde7f1d86f60~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在主轴方向上水平居中。</p><hr><h4 id="justify-content-space-between"><a href="#justify-content-space-between" class="headerlink" title="justify-content: space-between"></a>justify-content: space-between</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">justify-content: space-between</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75e64a2ddfb43b5b5728f65a81f34e2~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在主轴方向上<strong>两端对齐，项目之间间隔相等</strong>。</p><hr><h4 id="justify-content-space-around"><a href="#justify-content-space-around" class="headerlink" title="justify-content: space-around"></a>justify-content: space-around</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">justify-content: space-around</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c605040c45343a78b6596051d61e228~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在主轴方向上<strong>均匀排列每个元素，每个元素周围分配相同的空间</strong>。</p><hr><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>这个属性设置在父容器上，<strong>决定子元素在交叉轴方向上的对齐方式</strong>，我们看看它们具体表现吧👇</p><hr><h4 id="align-items-flex-start"><a href="#align-items-flex-start" class="headerlink" title="align-items: flex-start"></a>align-items: flex-start</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">align-items: flex-start</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcc92ecd68c34b0fb3ea75e2ff0b912b~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在交叉轴方向上起点对齐。</p><hr><h4 id="align-items-flex-end"><a href="#align-items-flex-end" class="headerlink" title="align-items: flex-end"></a>align-items: flex-end</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">align-items: flex-end</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a50fe990f88341d0a85b823b9ff3fb44~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在交叉轴方向上终点对齐。</p><hr><h4 id="align-items-center"><a href="#align-items-center" class="headerlink" title="align-items: center"></a>align-items: center</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">align-items: center</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f3b616efd946a5bffa5ffda877a78b~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在交叉轴方向上居中对齐。</p><hr><h4 id="align-items-baseline"><a href="#align-items-baseline" class="headerlink" title="align-items: baseline"></a>align-items: baseline</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">align-items: baseline</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bfe338236564e179134b7e961505951~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，子元素在交叉轴方向上以文字基线对齐，具体不清楚的，可以自行百度。</p><hr><h4 id="align-items-stretch"><a href="#align-items-stretch" class="headerlink" title="align-items: stretch"></a>align-items: stretch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你给父盒子(wrapper)设置属性</span><br><span class="line">align-items: stretch</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e641e25027ad41ec806f37756c0468d3~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结论</strong>，这个属性是默认的，如果项目未设置高度或者设为 auto，将占满整个容器的高度。</p><hr><h4 id="子容器"><a href="#子容器" class="headerlink" title="子容器"></a>子容器</h4><p>先看张图片</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d534c220aa642b7a60e67c9b8f19acd~tplv-k3u1fbpfcp-zoom-1.image"></p><p>子容器的话，这里就介绍两个属性👇</p><ul><li><code>flex</code>属性 定义在主轴是如何伸缩的<ul><li>子容器是有弹性的，它们会自动填充剩余空间，子容器的伸缩比由<code>flex</code>属性决定。</li><li>flex是多个属性的缩写，允许1-3个值的连写，具体参考上面的图。</li></ul></li><li><code>align-self</code>属性 <strong>单独设置子容器如何沿交叉轴排列</strong><ul><li>每个子容器都可以单独定义沿交叉轴排列方式。</li><li>该属性的取值跟父容器中的align-items属性一致，如果两者相同的话，则以子容器<code>align-self</code>属性为主。</li></ul></li></ul><h4 id="flex作用规则"><a href="#flex作用规则" class="headerlink" title="flex作用规则"></a>flex作用规则</h4><ul><li>三个属性的简写，是flex-grow flex-shrink flex-basis的简写</li><li>常用简化写法👇<ul><li>flex:1 —&gt; flex:1 1 0%;</li><li>flex:3 —&gt; flex:3 1 0%;</li><li>注意:flexbox布局和原来的布局是两个概念，部分css属性在flexbox盒子里面不起作用，eg：float， clear， column,vertical-align 等等</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意👉flex-grow  flex-shrink flex-basis 这三个属性会在后续介绍</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>具体的flex取值问题，可以参照下面的图👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d9db21dde9249ecbaa9204fd2397e4e~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h4 id="align-self作用规则"><a href="#align-self作用规则" class="headerlink" title="align-self作用规则"></a><strong>align-self作用规则</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 起始端对齐</span><br><span class="line">align-self : flex-start;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6a46b24f2b45d3ac93f9a9fffad31e~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 末尾段对齐</span><br><span class="line">align-self : flex-end;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e986cd6721f0486aaeb54ffe2dc93591~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基线对齐&#x2F;&#x2F; 末尾段对齐</span><br><span class="line">align-self : baseline;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5442ea2af1804d82a9cb9c977008ef0c~tplv-k3u1fbpfcp-zoom-1.image"></p><p>可以看到的话，它们对齐的方式是第一行文字的基线。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拉伸对齐</span><br><span class="line">align-self : stretch;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc1e80a04f504faa9b066974baea3972~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h2 id="flex更深入了解"><a href="#flex更深入了解" class="headerlink" title="flex更深入了解"></a>flex更深入了解</h2><p>上面介绍的常见几个属性掌握的话，基本上可以满足日常的开发布局需求，剩下的一些属性，接下来将梳理一遍，这样子的话，早日成为<code>flex布局进阶者</code>。</p><h3 id="父容器-1"><a href="#父容器-1" class="headerlink" title="父容器"></a>父容器</h3><ul><li><p><strong>flex-wrap</strong> 设置换行方式</p><ul><li>绝对子容器是否可以选择换行，一般而言有三种状态，支持换行的话，也支持逆序换行。</li></ul></li><li><p><strong>flex-flow</strong> 设置轴向与换行组合</p><ul><li>是 flex-direction 和 flex-wrap 的简写。</li><li>所以只要掌握，<code>flex-direction</code> 和 <code>flex-wrap</code>即可。</li></ul></li><li><p><strong>align-content</strong> 多行沿交叉轴对齐方式</p><ul><li>当子容器多行排列时，设置行与行之间的对齐方式。</li></ul></li></ul><hr><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>设置子容器的换行方式，通常有三个取值👇</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: wrap | nowrap | wrap-reverse</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>三种情况👇</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 允许换行</span><br><span class="line">flex-wrap : wrap</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06dd94f540de40faaaa41b5fea90a989~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不允许换行</span><br><span class="line">flex-wrap : nowrap</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d07888feba24c06a1b9c6cec1ab364b~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 允许逆向换行</span><br><span class="line">flex-wrap : wrap-reverse</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93dcac99b7a742309d55b831f1e8ecfd~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>先来一张图👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bee4c1a1e2aa4939aaec1168df9df15d~tplv-k3u1fbpfcp-zoom-1.image"></p><p><code>更多取值信息请查看</code> <a href="https://developer.mozilla.org/zh-CN/docs/CSS/flex-direction"><code>flex-direction</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/CSS/flex-wrap"><code>flex-wrap</code></a></p><p>可以查看MDN上，或者把之前的<code>flex-direction</code> 和 <code>flex-wrap</code> 两者取值看过一遍，那么使用这个属性就没有问题啦，这里也就不过多的举例子了，取值有三种情况👇</p><ul><li><p>单独设置flex-direction取值，比如</p><ul><li><pre><code class="css">flex-flow: row | column<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   单独设置flex-wrap取值</span><br><span class="line">    </span><br><span class="line">    *   &#96;&#96;&#96;css</span><br><span class="line">        flex-flow: wrap | nowrap | wrap-reverse</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>同时设置两者取值</p><ul><li><pre><code class="css">flex-flow: row wrapflex-flow: column nowrap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">#### align-content</span><br><span class="line"></span><br><span class="line">这个属性是定义子容器在交叉轴的排列方式，也就是对齐方式。</span><br><span class="line"></span><br><span class="line">首先上一张图👇</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;p3-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;e94951ca10cd4dc8bf74069ac13d6966~tplv-k3u1fbpfcp-zoom-1.image)</span><br><span class="line"></span><br><span class="line">根据这些取值，我们来看看布局效果吧👇</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 起始端对齐align-content: flex-start复制代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">效果👇</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;p3-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;b00aaeb582d3474e838db709ec66c3a8~tplv-k3u1fbpfcp-zoom-1.image)</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 末尾段对齐align-content: flex-end复制代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">效果👇</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;p6-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;ab3d9265288840fdb83e79f544a15d97~tplv-k3u1fbpfcp-zoom-1.image)</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 居中对齐align-content: center复制代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">效果👇</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;p9-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;023e04770fc54d7a93a5473fc2dbbd1e~tplv-k3u1fbpfcp-zoom-1.image)</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">&#x2F;&#x2F; 等间距均匀分布</span><br><span class="line">align-content: space-between</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>效果👇</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/145a1df4a0ca4a13b7320b762bf01a33~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 等边距均匀分布</span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">space-around</span></span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/666d82d1ba6142599a534f47c45e99ba~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 拉伸对齐</span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">stretch</span></span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fded204fd3e42babecb11f16eb51480~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 基线对齐</span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">baseline</span></span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8fda3bbdd140cdad6ee1cd6977bf76~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h3 id="子容器-1"><a href="#子容器-1" class="headerlink" title="子容器"></a>子容器</h3><ul><li><p><strong>flex-grow</strong> 设置扩展比例</p></li><li><p><strong>flex-shrink</strong> 设置收缩比例</p></li><li><p><strong>flex-basis</strong> 设置基准大小</p></li><li><p><strong>order</strong> 设置排列顺序</p></li></ul><hr><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>子容器弹性伸展的比例，简单理解，就是把剩余的空间按比例分配给子容器。</p><p>我们看个例子</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a4012640173402682c321785435b058~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>子容器弹性收缩的比例。简单理解，就是当你子容器超出的部分，会按照对应的比例给子容器减去对应的值。</p><p>我们来看下效果👇</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25a4c764286f4d41b9d7610764379c4b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>当取值为0时，就会溢出，那么我们给它们设置一个值👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f15ec185cdb4910a882c2fd6863aee4~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这样子的超出的部分就会按照比列减去。</p><hr><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>有几个点需要注意的是👇</p><ul><li><p>在不伸缩的情况下，<code>flex-basis</code>给子容器设置大小才有作用。</p></li><li><p>当主轴为横向时，即👇</p><ul><li><pre><code>flex-direction：row | row-reverse复制代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">    *   &#96;flex-basis&#96;设置的大小为宽度，并且会覆盖witdh值</span><br><span class="line">    </span><br><span class="line">*   当主轴为纵向时，即👇</span><br><span class="line">    </span><br><span class="line">    *   &#96;&#96;&#96;css</span><br><span class="line">        flex-direction：column | column-reverse</span><br></pre></td></tr></table></figure></code></pre></li><li><p><code>flex-basis</code>设置的大小为高度，并且会覆盖height值</p></li></ul></li></ul><p>我们来看看两种情况👇</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当主轴为横向时</span><br><span class="line">flex-direction：row | row-reverse</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef58a221bff243f48efdf0df099bd95b~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当主轴为纵向时</span><br><span class="line">flex-direction：column | column-reverse</span><br></pre></td></tr></table></figure><p>效果👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04b4154eee254445a2b8b32d90983d80~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><ul><li>每个子容器的<code>order</code>属性默认为0</li><li>通过设置<code>order</code>属性值，改变子容器的排列顺序。</li><li>可以是负值，数值越小的话，排的越靠前。</li></ul><p>直接看效果图👇</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4c34d31c8fe4273b0905933fd3f3291~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个时候，是不是需要总结一下呢👇</p><p>先看看子容器属性👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c5e529f03d345dab4534bf84b1cfd1d~tplv-k3u1fbpfcp-zoom-1.image"></p><hr><p>再看看父容器属性👇</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2e9733b84e040f296f827ff4148f235~tplv-k3u1fbpfcp-zoom-1.image"></p><p>梳理的是常见的属性值，对于一些不常见的属性值，请<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Flex">移步MDN</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
